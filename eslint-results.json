[{"filePath":"D:\\AISTECH\\travel-claim\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\next.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\postcss.config.js","messages":[{"ruleId":"import/no-anonymous-default-export","severity":1,"message":"Assign object to a variable before exporting as module default","line":1,"column":1,"nodeType":"ExportDefaultDeclaration","endLine":5,"endColumn":3}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export default {\r\n  plugins: {\r\n    \"@tailwindcss/postcss\": {},\r\n  },\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\prettier.config.js","messages":[{"ruleId":"import/no-anonymous-default-export","severity":1,"message":"Assign object to a variable before exporting as module default","line":2,"column":1,"nodeType":"ExportDefaultDeclaration","endLine":4,"endColumn":3}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @type {import('prettier').Config & import('prettier-plugin-tailwindcss').PluginOptions} */\r\nexport default {\r\n  plugins: [\"prettier-plugin-tailwindcss\"],\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\prisma\\seed.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chartOfAccounts' is assigned a value but never used.","line":22,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createDepartments' is defined but never used.","line":32,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createUsers' is defined but never used.","line":80,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2178,2181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2178,2181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":96,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":96,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .itDept on an `any` value.","line":96,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":113,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":113,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .financeDept on an `any` value.","line":113,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":130,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":130,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .salesDept on an `any` value.","line":130,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":147,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":147,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .salesDept on an `any` value.","line":147,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":147,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":165,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":165,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .salesDept on an `any` value.","line":165,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":165,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":183,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":183,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .salesDept on an `any` value.","line":183,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":183,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":200,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":200,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .itDept on an `any` value.","line":200,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":200,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":217,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":217,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .hrDept on an `any` value.","line":217,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":217,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6690,6693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6690,6693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":247,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":247,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":247,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":247,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":248,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":248,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":248,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":248,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":265,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":265,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":265,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":265,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":266,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":266,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":266,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":266,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":284,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":284,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":284,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":284,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":285,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":285,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":285,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":285,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":301,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":301,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":301,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":301,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":302,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":302,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":302,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":302,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":318,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":318,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":318,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":318,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":319,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":319,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":319,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":335,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":335,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":335,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":335,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":336,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":336,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":336,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":336,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":353,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":353,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":353,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":353,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":354,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":354,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":354,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":354,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":370,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":370,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":370,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":370,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":371,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":371,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":371,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":371,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":387,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":387,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":387,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":387,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":388,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":388,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":388,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":388,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":405,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":405,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":405,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":405,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":406,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":406,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":406,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":406,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":422,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":422,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":422,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":422,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":423,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":423,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":423,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":423,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":440,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":440,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":440,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":440,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":441,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":441,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":441,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":441,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":457,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":457,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":457,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":457,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":458,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":458,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":458,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":458,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":475,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":475,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":475,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":475,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":476,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":476,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":476,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":476,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":492,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":492,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":492,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":492,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":493,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":493,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":493,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":493,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":509,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":509,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":509,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":509,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":510,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":510,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":510,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":510,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":527,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":527,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":527,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":527,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":528,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":528,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":528,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":528,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":544,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":544,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":544,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":544,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":545,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":545,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `any` value.","line":545,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":545,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createTravelRequests' is defined but never used.","line":553,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":553,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":553,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":553,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16015,16018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16015,16018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":558,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":558,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee1 on an `any` value.","line":558,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":558,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee1 on an `any` value.","line":572,"column":94,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":572,"endColumn":103},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":577,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":577,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee2 on an `any` value.","line":577,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":577,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee2 on an `any` value.","line":588,"column":94,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":588,"endColumn":103},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":593,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":593,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .supervisor on an `any` value.","line":593,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":593,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .supervisor on an `any` value.","line":604,"column":94,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":604,"endColumn":104},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":610,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":610,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee3 on an `any` value.","line":610,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":610,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":626,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":626,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employee1 on an `any` value.","line":626,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":626,"endColumn":35}],"suppressedMessages":[],"errorCount":104,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from \"../generated/prisma/index.js\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function main() {\r\n  // console.log(\"ðŸŒ± Starting database seeding...\");\r\n\r\n  // // Create departments first\r\n  // const departments = await createDepartments();\r\n  // console.log(\"âœ… Departments created\");\r\n\r\n  // // Create users with different roles\r\n  // const users = await createUsers(departments);\r\n  // console.log(\"âœ… Users created\");\r\n\r\n  const admin = await prisma.user.findFirst(\r\n    { where: { role: \"ADMIN\" } }\r\n  );\r\n\r\n  // Create Chart of Accounts\r\n  const chartOfAccounts = await createChartOfAccounts(admin);\r\n  console.log(\"âœ… Chart of Accounts created\");\r\n\r\n  // Create travel requests with APPROVED status\r\n//   await createTravelRequests(users);\r\n//   console.log(\"âœ… Travel requests created\");\r\n\r\n//   console.log(\"ðŸŽ‰ Seeding completed successfully!\");\r\n}\r\n\r\nasync function createDepartments() {\r\n  // Create Sales Department\r\n  const salesDept = await prisma.department.upsert({\r\n    where: { code: \"SALES\" },\r\n    update: {},\r\n    create: {\r\n      code: \"SALES\",\r\n      name: \"Sales Department\",\r\n      description: \"Handles all sales operations and customer relations\",\r\n    },\r\n  });\r\n\r\n  // Create IT Department\r\n  const itDept = await prisma.department.upsert({\r\n    where: { code: \"IT\" },\r\n    update: {},\r\n    create: {\r\n      code: \"IT\",\r\n      name: \"IT Department\",\r\n      description: \"Information Technology and systems management\",\r\n    },\r\n  });\r\n\r\n  // Create Finance Department\r\n  const financeDept = await prisma.department.upsert({\r\n    where: { code: \"FINANCE\" },\r\n    update: {},\r\n    create: {\r\n      code: \"FINANCE\",\r\n      name: \"Finance Department\",\r\n      description: \"Financial operations and accounting\",\r\n    },\r\n  });\r\n\r\n  // Create HR Department\r\n  const hrDept = await prisma.department.upsert({\r\n    where: { code: \"HR\" },\r\n    update: {},\r\n    create: {\r\n      code: \"HR\",\r\n      name: \"Human Resources\",\r\n      description: \"Human resources and employee management\",\r\n    },\r\n  });\r\n\r\n  return { salesDept, itDept, financeDept, hrDept };\r\n}\r\n\r\nasync function createUsers(departments: any) {\r\n  const password = \"password123\"; // Default password for all test users\r\n  const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n  // Admin User\r\n  const admin = await prisma.user.upsert({\r\n    where: { email: \"admin@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"admin@company.com\",\r\n      name: \"Admin User\",\r\n      employeeId: \"EMP001\",\r\n      role: \"ADMIN\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456789\",\r\n      departmentId: departments.itDept.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Admin: admin@company.com / ${password}`);\r\n\r\n  // Finance User\r\n  const finance = await prisma.user.upsert({\r\n    where: { email: \"finance@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"finance@company.com\",\r\n      name: \"Finance Manager\",\r\n      employeeId: \"EMP002\",\r\n      role: \"FINANCE\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456790\",\r\n      departmentId: departments.financeDept.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Finance: finance@company.com / ${password}`);\r\n\r\n  // Director User\r\n  const director = await prisma.user.upsert({\r\n    where: { email: \"director@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"director@company.com\",\r\n      name: \"John Director\",\r\n      employeeId: \"EMP003\",\r\n      role: \"DIRECTOR\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456791\",\r\n      departmentId: departments.salesDept.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Director: director@company.com / ${password}`);\r\n\r\n  // Manager User\r\n  const manager = await prisma.user.upsert({\r\n    where: { email: \"manager@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"manager@company.com\",\r\n      name: \"Jane Manager\",\r\n      employeeId: \"EMP004\",\r\n      role: \"MANAGER\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456792\",\r\n      departmentId: departments.salesDept.id,\r\n      supervisorId: director.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Manager: manager@company.com / ${password}`);\r\n\r\n  // Supervisor User\r\n  const supervisor = await prisma.user.upsert({\r\n    where: { email: \"supervisor@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"supervisor@company.com\",\r\n      name: \"Bob Supervisor\",\r\n      employeeId: \"EMP005\",\r\n      role: \"SUPERVISOR\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456793\",\r\n      departmentId: departments.salesDept.id,\r\n      supervisorId: manager.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Supervisor: supervisor@company.com / ${password}`);\r\n\r\n  // Employee Users\r\n  const employee1 = await prisma.user.upsert({\r\n    where: { email: \"employee1@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"employee1@company.com\",\r\n      name: \"Alice Employee\",\r\n      employeeId: \"EMP006\",\r\n      role: \"EMPLOYEE\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456794\",\r\n      departmentId: departments.salesDept.id,\r\n      supervisorId: supervisor.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Employee 1: employee1@company.com / ${password}`);\r\n\r\n  const employee2 = await prisma.user.upsert({\r\n    where: { email: \"employee2@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"employee2@company.com\",\r\n      name: \"Charlie Employee\",\r\n      employeeId: \"EMP007\",\r\n      role: \"EMPLOYEE\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456795\",\r\n      departmentId: departments.itDept.id,\r\n      supervisorId: supervisor.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Employee 2: employee2@company.com / ${password}`);\r\n\r\n  const employee3 = await prisma.user.upsert({\r\n    where: { email: \"employee3@company.com\" },\r\n    update: {},\r\n    create: {\r\n      email: \"employee3@company.com\",\r\n      name: \"David Employee\",\r\n      employeeId: \"EMP008\",\r\n      role: \"EMPLOYEE\",\r\n      password: hashedPassword,\r\n      emailVerified: new Date(),\r\n      phoneNumber: \"+628123456796\",\r\n      departmentId: departments.hrDept.id,\r\n      supervisorId: supervisor.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ“§ Employee 3: employee3@company.com / ${password}`);\r\n\r\n  return {\r\n    admin,\r\n    finance,\r\n    director,\r\n    manager,\r\n    supervisor,\r\n    employee1,\r\n    employee2,\r\n    employee3,\r\n  };\r\n}\r\n\r\nasync function createChartOfAccounts(adminUser: any) {\r\n  // Create parent expense account\r\n  const expenseAccount = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6000\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6000\",\r\n      name: \"Operating Expenses\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Operating\",\r\n      isActive: true,\r\n      description: \"All operating expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created parent account: ${expenseAccount.code} - ${expenseAccount.name}`);\r\n\r\n  // Create travel & transportation expense accounts\r\n  const travelExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6100\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6100\",\r\n      name: \"Travel & Transportation\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Travel\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"All travel and transportation related expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${travelExpense.code} - ${travelExpense.name}`);\r\n\r\n  // Create subcategory accounts under Travel\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6110\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6110\",\r\n      name: \"Airfare\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Travel\",\r\n      subcategory: \"Transportation\",\r\n      parentId: travelExpense.id,\r\n      isActive: true,\r\n      description: \"Air travel expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6120\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6120\",\r\n      name: \"Ground Transportation\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Travel\",\r\n      subcategory: \"Transportation\",\r\n      parentId: travelExpense.id,\r\n      isActive: true,\r\n      description: \"Taxi, car rental, fuel, parking expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6130\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6130\",\r\n      name: \"Accommodation\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Travel\",\r\n      subcategory: \"Lodging\",\r\n      parentId: travelExpense.id,\r\n      isActive: true,\r\n      description: \"Hotel and lodging expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create meal & entertainment expense accounts\r\n  const mealExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6200\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6200\",\r\n      name: \"Meals & Entertainment\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Entertainment\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Business meals and entertainment expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${mealExpense.code} - ${mealExpense.name}`);\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6210\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6210\",\r\n      name: \"Business Meals\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Entertainment\",\r\n      subcategory: \"Meals\",\r\n      parentId: mealExpense.id,\r\n      isActive: true,\r\n      description: \"Business-related meal expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6220\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6220\",\r\n      name: \"Client Entertainment\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Entertainment\",\r\n      subcategory: \"Hospitality\",\r\n      parentId: mealExpense.id,\r\n      isActive: true,\r\n      description: \"Entertainment expenses for clients and prospects\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create communication expense accounts\r\n  const commExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6300\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6300\",\r\n      name: \"Communication Expenses\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Communication\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Phone, internet, and communication expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${commExpense.code} - ${commExpense.name}`);\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6310\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6310\",\r\n      name: \"Phone & Mobile\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Communication\",\r\n      subcategory: \"Telecommunications\",\r\n      parentId: commExpense.id,\r\n      isActive: true,\r\n      description: \"Phone and mobile billing expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create office & supplies expense accounts\r\n  const officeExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6400\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6400\",\r\n      name: \"Office & Supplies\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Office\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Office supplies and equipment expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${officeExpense.code} - ${officeExpense.name}`);\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6410\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6410\",\r\n      name: \"Stationery & Supplies\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Office\",\r\n      subcategory: \"Supplies\",\r\n      parentId: officeExpense.id,\r\n      isActive: true,\r\n      description: \"Office stationery and supplies\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create employee benefits expense accounts\r\n  const benefitsExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6500\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6500\",\r\n      name: \"Employee Benefits\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Benefits\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Employee benefits and welfare expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${benefitsExpense.code} - ${benefitsExpense.name}`);\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6510\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6510\",\r\n      name: \"BPJS & Health Insurance\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Benefits\",\r\n      subcategory: \"Insurance\",\r\n      parentId: benefitsExpense.id,\r\n      isActive: true,\r\n      description: \"BPJS health insurance and medical benefits\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6520\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6520\",\r\n      name: \"Overtime Meals\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Benefits\",\r\n      subcategory: \"Meals\",\r\n      parentId: benefitsExpense.id,\r\n      isActive: true,\r\n      description: \"Employee overtime meal allowances\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create vehicle & maintenance expense accounts\r\n  const vehicleExpense = await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6600\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6600\",\r\n      name: \"Vehicle Expenses\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Vehicle\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Vehicle-related expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: ${vehicleExpense.code} - ${vehicleExpense.name}`);\r\n\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6610\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6610\",\r\n      name: \"Vehicle Maintenance\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Vehicle\",\r\n      subcategory: \"Maintenance\",\r\n      parentId: vehicleExpense.id,\r\n      isActive: true,\r\n      description: \"Motorcycle and vehicle maintenance and service\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n\r\n  // Create miscellaneous expense account\r\n  await prisma.chartOfAccount.upsert({\r\n    where: { code: \"6900\" },\r\n    update: {},\r\n    create: {\r\n      code: \"6900\",\r\n      name: \"Other Expenses\",\r\n      accountType: \"EXPENSE\",\r\n      category: \"Miscellaneous\",\r\n      parentId: expenseAccount.id,\r\n      isActive: true,\r\n      description: \"Other miscellaneous business expenses\",\r\n      createdById: adminUser.id,\r\n      updatedById: adminUser.id,\r\n    },\r\n  });\r\n  console.log(`   ðŸ’° Created account: 6900 - Other Expenses`);\r\n\r\n  return { expenseAccount, travelExpense, mealExpense, commExpense, officeExpense, benefitsExpense, vehicleExpense };\r\n}\r\n\r\nasync function createTravelRequests(users: any) {\r\n  // Create APPROVED travel requests for different users\r\n  const approvedRequest1 = await prisma.travelRequest.create({\r\n    data: {\r\n      requestNumber: \"TR-2024-001\",\r\n      requesterId: users.employee1.id,\r\n      purpose: \"Client meeting and product demo in Jakarta\",\r\n      destination: \"Jakarta\",\r\n      travelType: \"SALES\",\r\n      startDate: new Date(\"2024-03-15\"),\r\n      endDate: new Date(\"2024-03-17\"),\r\n      estimatedBudget: 5000000,\r\n      status: \"APPROVED\",\r\n      projectName: \"Project Alpha\",\r\n      customerName: \"PT. Tech Solutions\",\r\n      salesPerson: \"Alice Employee\",\r\n      submittedAt: new Date(\"2024-03-01\"),\r\n    },\r\n  });\r\n  console.log(`   âœˆï¸  Approved Travel Request: ${approvedRequest1.requestNumber} for ${users.employee1.phoneNumber}`);\r\n\r\n  const approvedRequest2 = await prisma.travelRequest.create({\r\n    data: {\r\n      requestNumber: \"TR-2024-002\",\r\n      requesterId: users.employee2.id,\r\n      purpose: \"Training session on new technology stack\",\r\n      destination: \"Surabaya\",\r\n      travelType: \"TRAINING\",\r\n      startDate: new Date(\"2024-04-10\"),\r\n      endDate: new Date(\"2024-04-12\"),\r\n      estimatedBudget: 3500000,\r\n      status: \"APPROVED\",\r\n      submittedAt: new Date(\"2024-03-20\"),\r\n    },\r\n  });\r\n  console.log(`   âœˆï¸  Approved Travel Request: ${approvedRequest2.requestNumber} for ${users.employee2.phoneNumber}`);\r\n\r\n  const approvedRequest3 = await prisma.travelRequest.create({\r\n    data: {\r\n      requestNumber: \"TR-2024-003\",\r\n      requesterId: users.supervisor.id,\r\n      purpose: \"Quarterly business review meeting\",\r\n      destination: \"Bandung\",\r\n      travelType: \"MEETING\",\r\n      startDate: new Date(\"2024-05-05\"),\r\n      endDate: new Date(\"2024-05-07\"),\r\n      estimatedBudget: 4000000,\r\n      status: \"APPROVED\",\r\n      submittedAt: new Date(\"2024-04-15\"),\r\n    },\r\n  });\r\n  console.log(`   âœˆï¸  Approved Travel Request: ${approvedRequest3.requestNumber} for ${users.supervisor.phoneNumber}`);\r\n\r\n  // Create some non-APPROVED requests for comparison\r\n  await prisma.travelRequest.create({\r\n    data: {\r\n      requestNumber: \"TR-2024-004\",\r\n      requesterId: users.employee3.id,\r\n      purpose: \"Site visit for operational assessment\",\r\n      destination: \"Bali\",\r\n      travelType: \"OPERATIONAL\",\r\n      startDate: new Date(\"2024-06-01\"),\r\n      endDate: new Date(\"2024-06-03\"),\r\n      estimatedBudget: 6000000,\r\n      status: \"SUBMITTED\",\r\n      submittedAt: new Date(\"2024-05-15\"),\r\n    },\r\n  });\r\n  console.log(`   ðŸ“ Submitted Travel Request: TR-2024-004 (not APPROVED)`);\r\n\r\n  await prisma.travelRequest.create({\r\n    data: {\r\n      requestNumber: \"TR-2024-005\",\r\n      requesterId: users.employee1.id,\r\n      purpose: \"Follow-up meeting with existing clients\",\r\n      destination: \"Semarang\",\r\n      travelType: \"SALES\",\r\n      startDate: new Date(\"2024-07-10\"),\r\n      endDate: new Date(\"2024-07-12\"),\r\n      estimatedBudget: 3000000,\r\n      status: \"DRAFT\",\r\n    },\r\n  });\r\n  console.log(`   ðŸ“„ Draft Travel Request: TR-2024-005 (not APPROVED)`);\r\n\r\n  return { approvedRequest1, approvedRequest2, approvedRequest3 };\r\n}\r\n\r\nmain()\r\n  .catch((e) => {\r\n    console.error(\"âŒ Error during seeding:\", e);\r\n    process.exit(1);\r\n  })\r\n  .finally(async () => {\r\n    await prisma.$disconnect();\r\n  });","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\approvals\\page.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":91,"column":18,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[3233,3316],"text":"\r\n              You&apos;re all caught up! Check back later for new items.\r\n            "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[3233,3316],"text":"\r\n              You&lsquo;re all caught up! Check back later for new items.\r\n            "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[3233,3316],"text":"\r\n              You&#39;re all caught up! Check back later for new items.\r\n            "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[3233,3316],"text":"\r\n              You&rsquo;re all caught up! Check back later for new items.\r\n            "},"desc":"Replace with `&rsquo;`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Metadata } from \"next\";\r\nimport { redirect } from \"next/navigation\";\r\nimport { auth } from \"@/server/auth\";\r\n\r\nexport const metadata: Metadata = {\r\n  title: \"Approvals - Travel & Claim System\",\r\n  robots: { index: false, follow: false },\r\n};\r\n\r\nconst APPROVER_ROLES = [\r\n  \"SUPERVISOR\",\r\n  \"MANAGER\",\r\n  \"DIRECTOR\",\r\n  \"FINANCE_MANAGER\",\r\n  \"ADMIN\",\r\n];\r\n\r\nexport default async function ApprovalsPage() {\r\n  const session = await auth();\r\n  const userRole = session?.user?.role ?? \"EMPLOYEE\";\r\n\r\n  // Redirect employees to dashboard\r\n  if (!APPROVER_ROLES.includes(userRole)) {\r\n    redirect(\"/\");\r\n  }\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <div>\r\n          <h1 className=\"text-3xl font-bold text-gray-900\">Approvals</h1>\r\n          <p className=\"mt-2 text-gray-600\">\r\n            Review and approve pending requests and claims\r\n          </p>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Summary cards */}\r\n      <div className=\"grid gap-6 md:grid-cols-3\">\r\n        <div className=\"rounded-lg border border-orange-200 bg-orange-50 p-6\">\r\n          <p className=\"text-sm text-orange-900\">Pending Your Approval</p>\r\n          <p className=\"mt-2 text-3xl font-bold text-orange-900\">0</p>\r\n          <p className=\"mt-2 text-sm text-orange-800\">Requires action</p>\r\n        </div>\r\n        <div className=\"rounded-lg border bg-white p-6\">\r\n          <p className=\"text-sm text-gray-600\">Approved Today</p>\r\n          <p className=\"mt-2 text-3xl font-bold text-gray-900\">0</p>\r\n          <p className=\"mt-2 text-sm text-gray-600\">Items processed</p>\r\n        </div>\r\n        <div className=\"rounded-lg border bg-white p-6\">\r\n          <p className=\"text-sm text-gray-600\">Average Time</p>\r\n          <p className=\"mt-2 text-3xl font-bold text-gray-900\">-</p>\r\n          <p className=\"mt-2 text-sm text-gray-600\">To approve</p>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Filters */}\r\n      <div className=\"flex flex-wrap gap-4\">\r\n        <select className=\"rounded-lg border border-gray-300 px-4 py-2 text-sm\">\r\n          <option>All Types</option>\r\n          <option>Business Trip Requests</option>\r\n          <option>Claims</option>\r\n        </select>\r\n        <select className=\"rounded-lg border border-gray-300 px-4 py-2 text-sm\">\r\n          <option>All Status</option>\r\n          <option>Pending</option>\r\n          <option>Approved</option>\r\n          <option>Rejected</option>\r\n        </select>\r\n        <input\r\n          type=\"text\"\r\n          placeholder=\"Search by requester...\"\r\n          className=\"rounded-lg border border-gray-300 px-4 py-2 text-sm\"\r\n        />\r\n      </div>\r\n\r\n      {/* Pending approvals list */}\r\n      <div className=\"rounded-lg border bg-white\">\r\n        <div className=\"border-b p-4\">\r\n          <h2 className=\"text-lg font-semibold text-gray-900\">\r\n            Pending Approvals\r\n          </h2>\r\n        </div>\r\n        <div className=\"p-6\">\r\n          <div className=\"text-center py-12\">\r\n            <div className=\"text-6xl mb-4\">âœ…</div>\r\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">\r\n              No pending approvals\r\n            </h3>\r\n            <p className=\"text-gray-600\">\r\n              You're all caught up! Check back later for new items.\r\n            </p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Recent activity */}\r\n      <div className=\"rounded-lg border bg-white\">\r\n        <div className=\"border-b p-4\">\r\n          <h2 className=\"text-lg font-semibold text-gray-900\">\r\n            Recent Activity\r\n          </h2>\r\n        </div>\r\n        <div className=\"p-6\">\r\n          <div className=\"text-center py-8 text-gray-500\">\r\n            No recent approval activity\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\chart-of-accounts\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe object destructuring of a property with an `any` value.","line":31,"column":11,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":31,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe object destructuring of a property with an `any` value.","line":46,"column":11,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":46,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe object destructuring of a property with an `any` value.","line":61,"column":17,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":61,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'utils' is assigned a value but never used.","line":69,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":101,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isActive on an `any` value.","line":112,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":120,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":136,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accounts on an `any` value.","line":121,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":121,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":123,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":123,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accounts on an `any` value.","line":123,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":127,"column":7,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":132,"endColumn":8},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":127,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":127,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .filter on an `any` value.","line":127,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":127,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":135,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":135,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'action' is assigned a value but never used.","line":173,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":173,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":281,"column":35,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":281,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":297,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":297,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":317,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":317,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":327,"column":21,"nodeType":"Identifier","messageId":"anyAssignment","endLine":327,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":336,"column":21,"nodeType":"LogicalExpression","messageId":"anyAssignment","endLine":336,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":345,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":345,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":350,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":350,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":356,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":356,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .filter on an `any` value.","line":356,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":356,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":356,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":356,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":362,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":362,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .filter on an `any` value.","line":362,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":362,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":362,"column":72,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":362,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":368,"column":16,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":368,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .filter on an `any` value.","line":368,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":368,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":368,"column":88,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":368,"endColumn":94}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { useState, useMemo } from \"react\";\r\nimport { useSession } from \"next-auth/react\";\r\nimport { api } from \"@/trpc/react\";\r\nimport { PageHeader } from \"@/components/features/PageHeader\";\r\nimport { EmptyState } from \"@/components/features/EmptyState\";\r\nimport { COAFilters } from \"@/components/features/coa/COAFilters\";\r\nimport { COATable, type COAAccount } from \"@/components/features/coa/COATable\";\r\nimport { COAHierarchyView } from \"@/components/features/coa/COAHierarchyView\";\r\nimport { COAForm, type COAFormData } from \"@/components/features/coa/COAForm\";\r\nimport { Button } from \"@/components/ui/Button\";\r\nimport type { COAType } from \"../../../../generated/prisma\";\r\n\r\ntype ViewMode = \"table\" | \"hierarchy\";\r\n\r\nexport default function ChartOfAccountsPage() {\r\n  const { data: session } = useSession();\r\n  const [viewMode, setViewMode] = useState<ViewMode>(\"table\");\r\n  const [accountTypeFilter, setAccountTypeFilter] = useState<COAType | \"ALL\">(\"ALL\");\r\n  const [isActiveFilter, setIsActiveFilter] = useState<boolean | \"ALL\">(\"ALL\");\r\n  const [searchQuery, setSearchQuery] = useState(\"\");\r\n  const [isFormOpen, setIsFormOpen] = useState(false);\r\n  const [editingAccount, setEditingAccount] = useState<COAAccount | null>(null);\r\n\r\n  const userRole = session?.user?.role ?? \"EMPLOYEE\";\r\n  const isAdmin = userRole === \"ADMIN\";\r\n\r\n  // Fetch all accounts\r\n  const {\r\n    data: accountsData,\r\n    isLoading: isLoadingAccounts,\r\n    refetch: refetchAccounts,\r\n  } = api.chartOfAccount.getAll.useQuery(\r\n    {\r\n      accountType: accountTypeFilter === \"ALL\" ? undefined : accountTypeFilter,\r\n      isActive: isActiveFilter === \"ALL\" ? undefined : isActiveFilter,\r\n    },\r\n    {\r\n      refetchOnWindowFocus: false,\r\n    }\r\n  );\r\n\r\n  // Fetch hierarchy for tree view\r\n  const {\r\n    data: hierarchyData,\r\n    isLoading: isLoadingHierarchy,\r\n    refetch: refetchHierarchy,\r\n  } = api.chartOfAccount.getHierarchy.useQuery(\r\n    {\r\n      accountType: accountTypeFilter === \"ALL\" ? undefined : accountTypeFilter,\r\n      isActive: isActiveFilter === \"ALL\" ? undefined : isActiveFilter,\r\n    },\r\n    {\r\n      enabled: viewMode === \"hierarchy\",\r\n      refetchOnWindowFocus: false,\r\n    }\r\n  );\r\n\r\n  // Fetch active accounts for parent selection\r\n  const { data: activeAccounts } = api.chartOfAccount.getActiveAccounts.useQuery(\r\n    {},\r\n    {\r\n      refetchOnWindowFocus: false,\r\n    }\r\n  );\r\n\r\n  // Mutations\r\n  const utils = api.useUtils();\r\n\r\n  const createMutation = api.chartOfAccount.create.useMutation({\r\n    onSuccess: () => {\r\n      void refetchAccounts();\r\n      void refetchHierarchy();\r\n      setIsFormOpen(false);\r\n      setEditingAccount(null);\r\n      alert(\"Account created successfully!\");\r\n    },\r\n    onError: (error) => {\r\n      alert(`Error creating account: ${error.message}`);\r\n    },\r\n  });\r\n\r\n  const updateMutation = api.chartOfAccount.update.useMutation({\r\n    onSuccess: () => {\r\n      void refetchAccounts();\r\n      void refetchHierarchy();\r\n      setIsFormOpen(false);\r\n      setEditingAccount(null);\r\n      alert(\"Account updated successfully!\");\r\n    },\r\n    onError: (error) => {\r\n      alert(`Error updating account: ${error.message}`);\r\n    },\r\n  });\r\n\r\n  const deleteMutation = api.chartOfAccount.delete.useMutation({\r\n    onSuccess: (data) => {\r\n      void refetchAccounts();\r\n      void refetchHierarchy();\r\n      alert(data.message ?? \"Account deleted successfully!\");\r\n    },\r\n    onError: (error) => {\r\n      alert(`Error deleting account: ${error.message}`);\r\n    },\r\n  });\r\n\r\n  const toggleActiveMutation = api.chartOfAccount.toggleActive.useMutation({\r\n    onSuccess: (data) => {\r\n      void refetchAccounts();\r\n      void refetchHierarchy();\r\n      alert(`Account ${data.isActive ? \"activated\" : \"deactivated\"} successfully!`);\r\n    },\r\n    onError: (error) => {\r\n      alert(`Error toggling account status: ${error.message}`);\r\n    },\r\n  });\r\n\r\n  // Filter accounts by search query\r\n  const filteredAccounts = useMemo(() => {\r\n    if (!accountsData?.accounts) return [];\r\n\r\n    let filtered = accountsData.accounts;\r\n\r\n    if (searchQuery.trim()) {\r\n      const query = searchQuery.toLowerCase();\r\n      filtered = filtered.filter(\r\n        (acc: COAAccount) =>\r\n          acc.code.toLowerCase().includes(query) ||\r\n          acc.name.toLowerCase().includes(query) ||\r\n          acc.category.toLowerCase().includes(query)\r\n      );\r\n    }\r\n\r\n    return filtered;\r\n  }, [accountsData, searchQuery]);\r\n\r\n  // Handlers\r\n  const handleCreateNew = () => {\r\n    setEditingAccount(null);\r\n    setIsFormOpen(true);\r\n  };\r\n\r\n  const handleEdit = (account: COAAccount) => {\r\n    setEditingAccount(account);\r\n    setIsFormOpen(true);\r\n  };\r\n\r\n  const handleDelete = (account: COAAccount) => {\r\n    const hasChildren = (account._count?.children ?? 0) > 0;\r\n    const hasClaims = (account._count?.claims ?? 0) > 0;\r\n\r\n    if (hasChildren) {\r\n      alert(\"Cannot delete account with child accounts. Please delete or reassign child accounts first.\");\r\n      return;\r\n    }\r\n\r\n    let confirmMessage = `Are you sure you want to delete account \"${account.code} - ${account.name}\"?`;\r\n    \r\n    if (hasClaims) {\r\n      confirmMessage = `This account has ${account._count?.claims} associated claim(s). It will be deactivated instead of deleted. Continue?`;\r\n    }\r\n\r\n    if (confirm(confirmMessage)) {\r\n      deleteMutation.mutate({\r\n        id: account.id,\r\n        force: hasClaims,\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleToggleActive = (account: COAAccount) => {\r\n    const action = account.isActive ? \"deactivate\" : \"activate\";\r\n    const message = account.isActive\r\n      ? `Deactivating this account will also deactivate all its child accounts. Continue?`\r\n      : `Are you sure you want to activate account \"${account.code} - ${account.name}\"?`;\r\n\r\n    if (confirm(message)) {\r\n      toggleActiveMutation.mutate({ id: account.id });\r\n    }\r\n  };\r\n\r\n  const handleFormSubmit = (data: COAFormData) => {\r\n    if (editingAccount) {\r\n      updateMutation.mutate({\r\n        id: editingAccount.id,\r\n        ...data,\r\n        parentId: data.parentId || null,\r\n        subcategory: data.subcategory || null,\r\n        description: data.description || null,\r\n      });\r\n    } else {\r\n      createMutation.mutate({\r\n        ...data,\r\n        parentId: data.parentId || undefined,\r\n        subcategory: data.subcategory || undefined,\r\n        description: data.description || undefined,\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleFormCancel = () => {\r\n    setIsFormOpen(false);\r\n    setEditingAccount(null);\r\n  };\r\n\r\n  const isLoading = isLoadingAccounts || (viewMode === \"hierarchy\" && isLoadingHierarchy);\r\n  const isMutating =\r\n    createMutation.isPending ||\r\n    updateMutation.isPending ||\r\n    deleteMutation.isPending ||\r\n    toggleActiveMutation.isPending;\r\n\r\n  return (\r\n    <div className=\"space-y-6\">\r\n      <PageHeader\r\n        title=\"Chart of Accounts\"\r\n        description=\"Manage your financial account structure for expense tracking\"\r\n        primaryAction={\r\n          isAdmin\r\n            ? {\r\n                label: \"Create Account\",\r\n                onClick: handleCreateNew,\r\n              }\r\n            : undefined\r\n        }\r\n      />\r\n\r\n      {/* View Mode Toggle */}\r\n      <div className=\"flex items-center gap-2\">\r\n        <Button\r\n          size=\"sm\"\r\n          variant={viewMode === \"table\" ? \"primary\" : \"secondary\"}\r\n          onClick={() => setViewMode(\"table\")}\r\n        >\r\n          ðŸ“Š Table View\r\n        </Button>\r\n        <Button\r\n          size=\"sm\"\r\n          variant={viewMode === \"hierarchy\" ? \"primary\" : \"secondary\"}\r\n          onClick={() => setViewMode(\"hierarchy\")}\r\n        >\r\n          ðŸŒ³ Hierarchy View\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Filters */}\r\n      <COAFilters\r\n        accountType={accountTypeFilter}\r\n        onAccountTypeChange={setAccountTypeFilter}\r\n        isActive={isActiveFilter}\r\n        onIsActiveChange={setIsActiveFilter}\r\n        searchQuery={searchQuery}\r\n        onSearchChange={setSearchQuery}\r\n      />\r\n\r\n      {/* Form Modal/Panel */}\r\n      {isFormOpen && (\r\n        <div className=\"fixed inset-0 z-50 overflow-y-auto\">\r\n          <div className=\"flex min-h-screen items-center justify-center p-4\">\r\n            <div\r\n              className=\"fixed inset-0 bg-black bg-opacity-30 transition-opacity\"\r\n              onClick={handleFormCancel}\r\n            />\r\n            <div className=\"relative w-full max-w-3xl rounded-lg bg-white p-6 shadow-xl\">\r\n              <h2 className=\"text-2xl font-bold text-gray-900 mb-6\">\r\n                {editingAccount ? \"Edit Account\" : \"Create New Account\"}\r\n              </h2>\r\n              <COAForm\r\n                initialData={editingAccount ? {\r\n                  id: editingAccount.id,\r\n                  code: editingAccount.code,\r\n                  name: editingAccount.name,\r\n                  accountType: editingAccount.accountType,\r\n                  category: editingAccount.category,\r\n                  subcategory: editingAccount.subcategory ?? \"\",\r\n                  parentId: editingAccount.parentId ?? \"\",\r\n                  description: \"\",\r\n                  isActive: editingAccount.isActive,\r\n                } : undefined}\r\n                availableParents={activeAccounts ?? []}\r\n                isLoading={isMutating}\r\n                onSubmit={handleFormSubmit}\r\n                onCancel={handleFormCancel}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* Content */}\r\n      {isLoading ? (\r\n        <div className=\"rounded-lg border bg-white p-12 text-center\">\r\n          <div className=\"inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-blue-600 border-r-transparent\"></div>\r\n          <p className=\"mt-4 text-sm text-gray-600\">Loading accounts...</p>\r\n        </div>\r\n      ) : filteredAccounts.length === 0 && !searchQuery ? (\r\n        <div className=\"rounded-lg border bg-white\">\r\n          <EmptyState\r\n            icon=\"ðŸ’¼\"\r\n            title=\"No chart of accounts yet\"\r\n            description={\r\n              isAdmin\r\n                ? \"Create your first account to start organizing financial data\"\r\n                : \"No accounts available. Contact your administrator.\"\r\n            }\r\n            action={\r\n              isAdmin\r\n                ? {\r\n                    label: \"Create First Account\",\r\n                    onClick: handleCreateNew,\r\n                  }\r\n                : undefined\r\n            }\r\n          />\r\n        </div>\r\n      ) : filteredAccounts.length === 0 && searchQuery ? (\r\n        <div className=\"rounded-lg border bg-white\">\r\n          <EmptyState\r\n            icon=\"ðŸ”\"\r\n            title=\"No accounts found\"\r\n            description={`No accounts match \"${searchQuery}\". Try a different search term.`}\r\n          />\r\n        </div>\r\n      ) : viewMode === \"table\" ? (\r\n        <COATable\r\n          accounts={filteredAccounts}\r\n          isLoading={false}\r\n          userRole={userRole}\r\n          onEdit={handleEdit}\r\n          onDelete={handleDelete}\r\n          onToggleActive={handleToggleActive}\r\n        />\r\n      ) : (\r\n        <COAHierarchyView\r\n          accounts={hierarchyData ?? []}\r\n          isLoading={isLoadingHierarchy}\r\n          userRole={userRole}\r\n          onEdit={(account) => handleEdit(account as COAAccount)}\r\n          onToggleActive={(account) => handleToggleActive(account as COAAccount)}\r\n        />\r\n      )}\r\n\r\n      {/* Summary Stats */}\r\n      {filteredAccounts.length > 0 && (\r\n        <div className=\"grid gap-6 md:grid-cols-4\">\r\n          <div className=\"rounded-lg border bg-white p-6\">\r\n            <p className=\"text-sm text-gray-600\">Total Accounts</p>\r\n            <p className=\"mt-2 text-3xl font-bold text-gray-900\">\r\n              {filteredAccounts.length}\r\n            </p>\r\n          </div>\r\n          <div className=\"rounded-lg border bg-green-50 p-6\">\r\n            <p className=\"text-sm text-green-900\">Active</p>\r\n            <p className=\"mt-2 text-3xl font-bold text-green-900\">\r\n              {filteredAccounts.filter((a: COAAccount) => a.isActive).length}\r\n            </p>\r\n          </div>\r\n          <div className=\"rounded-lg border bg-gray-50 p-6\">\r\n            <p className=\"text-sm text-gray-700\">Inactive</p>\r\n            <p className=\"mt-2 text-3xl font-bold text-gray-700\">\r\n              {filteredAccounts.filter((a: COAAccount) => !a.isActive).length}\r\n            </p>\r\n          </div>\r\n          <div className=\"rounded-lg border bg-blue-50 p-6\">\r\n            <p className=\"text-sm text-blue-900\">With Claims</p>\r\n            <p className=\"mt-2 text-3xl font-bold text-blue-900\">\r\n              {filteredAccounts.filter((a: COAAccount) => (a._count?.claims ?? 0) > 0).length}\r\n            </p>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\claims\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\dashboard\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\loading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(authenticated)\\travel\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(public)\\api-docs\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\(public)\\login\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'status' is assigned a value but never used.","line":18,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n// import type { Metadata } from \"next\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { signIn, useSession } from \"next-auth/react\";\r\nimport { useState, useEffect } from \"react\";\r\n\r\n// export const metadata: Metadata = {\r\n//   title: \"Sign In - Travel & Claim System\",\r\n//   description: \"Sign in with your Microsoft account to access the Travel & Claim System\",\r\n//   robots: {\r\n//     index: false,\r\n//     follow: false,\r\n//   },\r\n// };\r\n\r\nexport default function LoginPage() {\r\n   const router = useRouter();\r\n   const { data: session, status } = useSession();\r\n   const [email, setEmail] = useState(\"\");\r\n   const [password, setPassword] = useState(\"\");\r\n   const [error, setError] = useState(\"\");\r\n   const [isLoading, setIsLoading] = useState(false);\r\n  \r\n  // Redirect to dashboard if already authenticated\r\n  useEffect(() => {\r\n    if (session) {\r\n      router.push(\"/\");\r\n    }\r\n  }, [session, router]);\r\n\r\n  const handleCredentialsLogin = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    setError(\"\");\r\n    setIsLoading(true);\r\n\r\n    try {\r\n      console.log(\"Attempting login with:\", email);\r\n      const result = await signIn(\"credentials\", {\r\n        email,\r\n        password,\r\n        redirect: false,\r\n        callbackUrl: \"/\",\r\n      });\r\n\r\n      console.log(\"Login result:\", result);\r\n\r\n      if (result?.error) {\r\n        console.error(\"Login error:\", result.error);\r\n        setError(result.error);\r\n        setIsLoading(false);\r\n      } else if (result?.ok) {\r\n        console.log(\"Login successful, redirecting...\");\r\n        // Successfully logged in, redirect to home\r\n        window.location.href = \"/\";\r\n      } else {\r\n        setError(\"Login failed. Please check your credentials.\");\r\n        setIsLoading(false);\r\n      }\r\n    } catch (err) {\r\n      console.error(\"Login exception:\", err);\r\n      setError(\"An error occurred during sign in\");\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  // const handleGoogleLogin = () => {\r\n  //   signIn(\"google\", {\r\n  //     callbackUrl: \"/\",\r\n  //   });\r\n  // };\r\n\r\n  return (\r\n    <div className=\"flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8\">\r\n      <div className=\"w-full max-w-md space-y-8\">\r\n        <div className=\"text-center\">\r\n          <div className=\"mx-auto h-12 w-12 rounded-lg bg-blue-600\" />\r\n          <h2 className=\"mt-6 text-3xl font-bold tracking-tight text-gray-900\">\r\n            Travel & Claim System\r\n          </h2>\r\n          <p className=\"mt-2 text-sm text-gray-600\">\r\n            Sign in to continue\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"mt-8 rounded-lg bg-white px-6 py-8 shadow-md\">\r\n          {/* Email/Password Login Form */}\r\n          <form onSubmit={handleCredentialsLogin} className=\"space-y-4\">\r\n            <div>\r\n              <label htmlFor=\"email\" className=\"block text-sm font-medium text-gray-700\">\r\n                Email\r\n              </label>\r\n              <input\r\n                id=\"email\"\r\n                type=\"email\"\r\n                value={email}\r\n                onChange={(e) => setEmail(e.target.value)}\r\n                required\r\n                className=\"mt-1 block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                placeholder=\"your.email@example.com\"\r\n                disabled={isLoading}\r\n              />\r\n            </div>\r\n\r\n            <div>\r\n              <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700\">\r\n                Password\r\n              </label>\r\n              <input\r\n                id=\"password\"\r\n                type=\"password\"\r\n                value={password}\r\n                onChange={(e) => setPassword(e.target.value)}\r\n                required\r\n                className=\"mt-1 block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                placeholder=\"â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢\"\r\n                disabled={isLoading}\r\n              />\r\n            </div>\r\n\r\n            {error && (\r\n              <div className=\"rounded-lg bg-red-50 p-3 text-sm text-red-800\">\r\n                {error}\r\n              </div>\r\n            )}\r\n\r\n            <button\r\n              type=\"submit\"\r\n              disabled={isLoading}\r\n              className=\"flex w-full items-center justify-center rounded-lg bg-blue-600 px-4 py-3 text-sm font-semibold text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed\"\r\n            >\r\n              {isLoading ? \"Signing in...\" : \"Sign in with Email\"}\r\n            </button>\r\n          </form>\r\n\r\n          {/* Divider */}\r\n          <div className=\"relative my-6\">\r\n            <div className=\"absolute inset-0 flex items-center\">\r\n              <div className=\"w-full border-t border-gray-300\" />\r\n            </div>\r\n            <div className=\"relative flex justify-center text-sm\">\r\n              <span className=\"bg-white px-2 text-gray-500\">Or continue with</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Microsoft Sign-in */}\r\n          <form action=\"/api/auth/signin/azure-ad\" method=\"POST\">\r\n            <button\r\n              type=\"submit\"\r\n              className=\"flex w-full items-center justify-center gap-3 rounded-lg border border-gray-300 bg-white px-4 py-3 text-sm font-semibold text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\r\n            >\r\n              <svg\r\n                className=\"h-5 w-5\"\r\n                viewBox=\"0 0 21 21\"\r\n                fill=\"none\"\r\n                xmlns=\"http://www.w3.org/2000/svg\"\r\n              >\r\n                <rect\r\n                  x=\"1\"\r\n                  y=\"1\"\r\n                  width=\"9\"\r\n                  height=\"9\"\r\n                  fill=\"#F25022\"\r\n                />\r\n                <rect\r\n                  x=\"1\"\r\n                  y=\"11\"\r\n                  width=\"9\"\r\n                  height=\"9\"\r\n                  fill=\"#00A4EF\"\r\n                />\r\n                <rect\r\n                  x=\"11\"\r\n                  y=\"1\"\r\n                  width=\"9\"\r\n                  height=\"9\"\r\n                  fill=\"#7FBA00\"\r\n                />\r\n                <rect\r\n                  x=\"11\"\r\n                  y=\"11\"\r\n                  width=\"9\"\r\n                  height=\"9\"\r\n                  fill=\"#FFB900\"\r\n                />\r\n              </svg>\r\n              Sign in with Microsoft\r\n            </button>\r\n          </form>\r\n                {/* <button\r\n                    type=\"button\"\r\n                    onClick={handleGoogleLogin}\r\n                   className=\"flex w-full items-center justify-center gap-3 rounded-lg border border-gray-300 bg-white px-4 py-3 text-sm font-semibold text-gray-700 hover:bg-gray-50 \"\r\n                  >\r\n                    <img\r\n                      src=\"/assets/google-lime.png\"\r\n                      alt=\"google-icon\"\r\n                      className=\"h-5 w-5\"\r\n                    />\r\n                    <span>Log in with Google</span>\r\n                  </button> */}\r\n\r\n          <div className=\"mt-6 text-center\">\r\n            <p className=\"text-xs text-gray-500\">\r\n              By signing in, you agree to our{\" \"}\r\n              <a href=\"#\" className=\"text-blue-600 hover:text-blue-700\">\r\n                Terms of Service\r\n              </a>{\" \"}\r\n              and{\" \"}\r\n              <a href=\"#\" className=\"text-blue-600 hover:text-blue-700\">\r\n                Privacy Policy\r\n              </a>\r\n            </p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"rounded-lg border border-blue-100 bg-blue-50 p-4\">\r\n          <h3 className=\"mb-2 text-sm font-semibold text-blue-900\">\r\n            Need Help?\r\n          </h3>\r\n          <p className=\"text-xs text-blue-800\">\r\n            If you&apos;re having trouble signing in, please contact your IT administrator \r\n            or email support@example.com for assistance.\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"text-center text-sm text-gray-600\">\r\n          <p>\r\n            Don&apos;t have access?{\" \"}\r\n            <a href=\"#\" className=\"font-medium text-blue-600 hover:text-blue-700\">\r\n              Request Access\r\n            </a>\r\n          </p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\api\\[...trpc]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\api\\auth\\[...nextauth]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\api\\mcp\\[transport]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\api\\openapi.json\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { openApiDocument } from \"@/server/openapi\";\r\nimport { type NextRequest } from \"next/server\";\r\n\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nexport function GET(req: NextRequest) {\r\n  return Response.json(openApiDocument, {\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n  });\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\api\\trpc\\[trpc]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\error.tsx","messages":[{"ruleId":"react/no-unescaped-entities","severity":2,"message":"`'` can be escaped with `&apos;`, `&lsquo;`, `&#39;`, `&rsquo;`.","line":25,"column":13,"nodeType":"JSXText","messageId":"unescapedEntityAlts","suggestions":[{"messageId":"replaceWithAlt","data":{"alt":"&apos;"},"fix":{"range":[641,728],"text":"\r\n          We&apos;re sorry, but something unexpected happened. Please try again.\r\n        "},"desc":"Replace with `&apos;`."},{"messageId":"replaceWithAlt","data":{"alt":"&lsquo;"},"fix":{"range":[641,728],"text":"\r\n          We&lsquo;re sorry, but something unexpected happened. Please try again.\r\n        "},"desc":"Replace with `&lsquo;`."},{"messageId":"replaceWithAlt","data":{"alt":"&#39;"},"fix":{"range":[641,728],"text":"\r\n          We&#39;re sorry, but something unexpected happened. Please try again.\r\n        "},"desc":"Replace with `&#39;`."},{"messageId":"replaceWithAlt","data":{"alt":"&rsquo;"},"fix":{"range":[641,728],"text":"\r\n          We&rsquo;re sorry, but something unexpected happened. Please try again.\r\n        "},"desc":"Replace with `&rsquo;`."}]},{"ruleId":"@next/next/no-html-link-for-pages","severity":2,"message":"Do not use an `<a>` element to navigate to `/`. Use `<Link />` from `next/link` instead. See: https://nextjs.org/docs/messages/no-html-link-for-pages","line":34,"column":11,"nodeType":"JSXOpeningElement","endLine":37,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { useEffect } from \"react\";\r\n\r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string };\r\n  reset: () => void;\r\n}) {\r\n  useEffect(() => {\r\n    // Log the error to an error reporting service\r\n    console.error(error);\r\n  }, [error]);\r\n\r\n  return (\r\n    <div className=\"flex h-screen items-center justify-center bg-gray-50 px-4\">\r\n      <div className=\"max-w-md text-center\">\r\n        <div className=\"mb-6 text-6xl\">âš ï¸</div>\r\n        <h2 className=\"mb-4 text-2xl font-bold text-gray-900\">\r\n          Something went wrong!\r\n        </h2>\r\n        <p className=\"mb-6 text-gray-600\">\r\n          We're sorry, but something unexpected happened. Please try again.\r\n        </p>\r\n        <div className=\"space-x-4\">\r\n          <button\r\n            onClick={reset}\r\n            className=\"rounded-lg bg-blue-600 px-6 py-2 text-sm font-semibold text-white hover:bg-blue-700\"\r\n          >\r\n            Try Again\r\n          </button>\r\n          <a\r\n            href=\"/\"\r\n            className=\"inline-block rounded-lg border border-gray-300 px-6 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50\"\r\n          >\r\n            Go Home\r\n          </a>\r\n        </div>\r\n        {error.digest && (\r\n          <p className=\"mt-6 text-xs text-gray-500\">Error ID: {error.digest}</p>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\loading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\PageHeader.tsx","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":39,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":39,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[942,944],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type ReactNode } from \"react\";\r\nimport { Button } from \"@/components/ui/Button\";\r\n\r\ninterface PageHeaderProps {\r\n  title: string;\r\n  description?: string;\r\n  badge?: ReactNode;\r\n  primaryAction?: {\r\n    label: string;\r\n    href?: string;\r\n    onClick?: () => void;\r\n  };\r\n  secondaryAction?: {\r\n    label: string;\r\n    href?: string;\r\n    onClick?: () => void;\r\n  };\r\n}\r\n\r\nexport function PageHeader({\r\n  title,\r\n  description,\r\n  badge,\r\n  primaryAction,\r\n  secondaryAction,\r\n}: PageHeaderProps) {\r\n  return (\r\n    <div className=\"flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between\">\r\n      <div className=\"flex-1\">\r\n        <div className=\"flex items-center gap-3\">\r\n          <h1 className=\"text-3xl font-bold text-gray-900\">{title}</h1>\r\n          {badge}\r\n        </div>\r\n        {description && (\r\n          <p className=\"mt-2 text-gray-600\">{description}</p>\r\n        )}\r\n      </div>\r\n\r\n      {(primaryAction || secondaryAction) && (\r\n        <div className=\"flex items-center gap-3\">\r\n          {secondaryAction && (\r\n            <>\r\n              {secondaryAction.href ? (\r\n                <a\r\n                  href={secondaryAction.href}\r\n                  className=\"rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50\"\r\n                >\r\n                  {secondaryAction.label}\r\n                </a>\r\n              ) : (\r\n                <Button\r\n                  variant=\"secondary\"\r\n                  onClick={secondaryAction.onClick}\r\n                >\r\n                  {secondaryAction.label}\r\n                </Button>\r\n              )}\r\n            </>\r\n          )}\r\n          {primaryAction && (\r\n            <>\r\n              {primaryAction.href ? (\r\n                <a\r\n                  href={primaryAction.href}\r\n                  className=\"rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700\"\r\n                >\r\n                  {primaryAction.label}\r\n                </a>\r\n              ) : (\r\n                <Button onClick={primaryAction.onClick}>\r\n                  {primaryAction.label}\r\n                </Button>\r\n              )}\r\n            </>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\StatCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\StatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\coa\\COAFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\coa\\COAForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":3,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":29,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"useEffect"},"fix":{"range":[34,45],"text":""},"desc":"Remove unused variable \"useEffect\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { useState, useEffect } from \"react\";\r\nimport { Button } from \"@/components/ui/Button\";\r\nimport type { COAType } from \"../../../../generated/prisma\";\r\n\r\nexport interface COAFormData {\r\n  code: string;\r\n  name: string;\r\n  accountType: COAType;\r\n  category: string;\r\n  subcategory: string;\r\n  parentId: string;\r\n  description: string;\r\n  isActive: boolean;\r\n}\r\n\r\ninterface COAFormProps {\r\n  initialData?: Partial<COAFormData> & { id?: string };\r\n  availableParents: Array<{\r\n    id: string;\r\n    code: string;\r\n    name: string;\r\n    accountType: COAType;\r\n    parentId: string | null;\r\n  }>;\r\n  isLoading?: boolean;\r\n  onSubmit: (data: COAFormData) => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nconst ACCOUNT_TYPES: Array<{ value: COAType; label: string }> = [\r\n  { value: \"ASSET\", label: \"Asset\" },\r\n  { value: \"LIABILITY\", label: \"Liability\" },\r\n  { value: \"EQUITY\", label: \"Equity\" },\r\n  { value: \"REVENUE\", label: \"Revenue\" },\r\n  { value: \"EXPENSE\", label: \"Expense\" },\r\n];\r\n\r\nexport function COAForm({\r\n  initialData,\r\n  availableParents,\r\n  isLoading,\r\n  onSubmit,\r\n  onCancel,\r\n}: COAFormProps) {\r\n  const [formData, setFormData] = useState<COAFormData>({\r\n    code: initialData?.code ?? \"\",\r\n    name: initialData?.name ?? \"\",\r\n    accountType: initialData?.accountType ?? \"EXPENSE\",\r\n    category: initialData?.category ?? \"\",\r\n    subcategory: initialData?.subcategory ?? \"\",\r\n    parentId: initialData?.parentId ?? \"\",\r\n    description: initialData?.description ?? \"\",\r\n    isActive: initialData?.isActive ?? true,\r\n  });\r\n\r\n  const [errors, setErrors] = useState<Partial<Record<keyof COAFormData, string>>>({});\r\n\r\n  // Filter parents by selected account type\r\n  const filteredParents = availableParents.filter(\r\n    (parent) =>\r\n      parent.accountType === formData.accountType &&\r\n      parent.id !== initialData?.id // Prevent self-parenting\r\n  );\r\n\r\n  // Build hierarchical parent list for display\r\n  const buildHierarchicalName = (parent: typeof availableParents[0]): string => {\r\n    const parentOfParent = availableParents.find((p) => p.id === parent.parentId);\r\n    if (parentOfParent) {\r\n      return `${buildHierarchicalName(parentOfParent)} > ${parent.code} - ${parent.name}`;\r\n    }\r\n    return `${parent.code} - ${parent.name}`;\r\n  };\r\n\r\n  const validateForm = (): boolean => {\r\n    const newErrors: Partial<Record<keyof COAFormData, string>> = {};\r\n\r\n    if (!formData.code.trim()) {\r\n      newErrors.code = \"Account code is required\";\r\n    } else if (!/^[A-Z0-9-]+$/.test(formData.code)) {\r\n      newErrors.code = \"Code must contain only uppercase letters, numbers, and hyphens\";\r\n    }\r\n\r\n    if (!formData.name.trim()) {\r\n      newErrors.name = \"Account name is required\";\r\n    }\r\n\r\n    if (!formData.category.trim()) {\r\n      newErrors.category = \"Category is required\";\r\n    }\r\n\r\n    setErrors(newErrors);\r\n    return Object.keys(newErrors).length === 0;\r\n  };\r\n\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    if (validateForm()) {\r\n      onSubmit(formData);\r\n    }\r\n  };\r\n\r\n  const handleChange = (\r\n    field: keyof COAFormData,\r\n    value: string | boolean\r\n  ) => {\r\n    setFormData((prev) => ({ ...prev, [field]: value }));\r\n    // Clear error when user starts typing\r\n    if (errors[field]) {\r\n      setErrors((prev) => ({ ...prev, [field]: undefined }));\r\n    }\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit} className=\"space-y-6\">\r\n      <div className=\"grid gap-6 md:grid-cols-2\">\r\n        {/* Account Code */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Account Code <span className=\"text-red-500\">*</span>\r\n          </label>\r\n          <input\r\n            type=\"text\"\r\n            value={formData.code}\r\n            onChange={(e) => handleChange(\"code\", e.target.value.toUpperCase())}\r\n            placeholder=\"e.g., EXP-001\"\r\n            className={`w-full rounded-lg border px-4 py-2 text-sm font-mono focus:outline-none focus:ring-2 ${\r\n              errors.code\r\n                ? \"border-red-500 focus:ring-red-500\"\r\n                : \"border-gray-300 focus:ring-blue-500\"\r\n            }`}\r\n            disabled={isLoading}\r\n          />\r\n          {errors.code && (\r\n            <p className=\"mt-1 text-sm text-red-600\">{errors.code}</p>\r\n          )}\r\n        </div>\r\n\r\n        {/* Account Name */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Account Name <span className=\"text-red-500\">*</span>\r\n          </label>\r\n          <input\r\n            type=\"text\"\r\n            value={formData.name}\r\n            onChange={(e) => handleChange(\"name\", e.target.value)}\r\n            placeholder=\"e.g., Travel Expenses\"\r\n            className={`w-full rounded-lg border px-4 py-2 text-sm focus:outline-none focus:ring-2 ${\r\n              errors.name\r\n                ? \"border-red-500 focus:ring-red-500\"\r\n                : \"border-gray-300 focus:ring-blue-500\"\r\n            }`}\r\n            disabled={isLoading}\r\n          />\r\n          {errors.name && (\r\n            <p className=\"mt-1 text-sm text-red-600\">{errors.name}</p>\r\n          )}\r\n        </div>\r\n\r\n        {/* Account Type */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Account Type <span className=\"text-red-500\">*</span>\r\n          </label>\r\n          <select\r\n            value={formData.accountType}\r\n            onChange={(e) => {\r\n              handleChange(\"accountType\", e.target.value as COAType);\r\n              // Reset parent when account type changes\r\n              handleChange(\"parentId\", \"\");\r\n            }}\r\n            className=\"w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n            disabled={isLoading}\r\n          >\r\n            {ACCOUNT_TYPES.map((type) => (\r\n              <option key={type.value} value={type.value}>\r\n                {type.label}\r\n              </option>\r\n            ))}\r\n          </select>\r\n        </div>\r\n\r\n        {/* Category */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Category <span className=\"text-red-500\">*</span>\r\n          </label>\r\n          <input\r\n            type=\"text\"\r\n            value={formData.category}\r\n            onChange={(e) => handleChange(\"category\", e.target.value)}\r\n            placeholder=\"e.g., Operating Expenses\"\r\n            className={`w-full rounded-lg border px-4 py-2 text-sm focus:outline-none focus:ring-2 ${\r\n              errors.category\r\n                ? \"border-red-500 focus:ring-red-500\"\r\n                : \"border-gray-300 focus:ring-blue-500\"\r\n            }`}\r\n            disabled={isLoading}\r\n          />\r\n          {errors.category && (\r\n            <p className=\"mt-1 text-sm text-red-600\">{errors.category}</p>\r\n          )}\r\n        </div>\r\n\r\n        {/* Subcategory */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Subcategory\r\n          </label>\r\n          <input\r\n            type=\"text\"\r\n            value={formData.subcategory}\r\n            onChange={(e) => handleChange(\"subcategory\", e.target.value)}\r\n            placeholder=\"e.g., International Travel\"\r\n            className=\"w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n            disabled={isLoading}\r\n          />\r\n        </div>\r\n\r\n        {/* Parent Account */}\r\n        <div>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            Parent Account\r\n          </label>\r\n          <select\r\n            value={formData.parentId}\r\n            onChange={(e) => handleChange(\"parentId\", e.target.value)}\r\n            className=\"w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n            disabled={isLoading}\r\n          >\r\n            <option value=\"\">None (Root Account)</option>\r\n            {filteredParents.map((parent) => (\r\n              <option key={parent.id} value={parent.id}>\r\n                {buildHierarchicalName(parent)}\r\n              </option>\r\n            ))}\r\n          </select>\r\n          <p className=\"mt-1 text-xs text-gray-500\">\r\n            Only {formData.accountType} accounts shown\r\n          </p>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Description */}\r\n      <div>\r\n        <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n          Description\r\n        </label>\r\n        <textarea\r\n          value={formData.description}\r\n          onChange={(e) => handleChange(\"description\", e.target.value)}\r\n          placeholder=\"Optional account description...\"\r\n          rows={3}\r\n          className=\"w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n          disabled={isLoading}\r\n        />\r\n      </div>\r\n\r\n      {/* Active Status */}\r\n      <div className=\"flex items-center gap-3\">\r\n        <input\r\n          type=\"checkbox\"\r\n          id=\"isActive\"\r\n          checked={formData.isActive}\r\n          onChange={(e) => handleChange(\"isActive\", e.target.checked)}\r\n          className=\"h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\r\n          disabled={isLoading}\r\n        />\r\n        <label htmlFor=\"isActive\" className=\"text-sm font-medium text-gray-700\">\r\n          Active (available for use in claims)\r\n        </label>\r\n      </div>\r\n\r\n      {/* Form Actions */}\r\n      <div className=\"flex items-center justify-end gap-3 pt-4 border-t\">\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"secondary\"\r\n          onClick={onCancel}\r\n          disabled={isLoading}\r\n        >\r\n          Cancel\r\n        </Button>\r\n        <Button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? (\r\n            <>\r\n              <span className=\"inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-white border-r-transparent mr-2\"></span>\r\n              {initialData?.id ? \"Updating...\" : \"Creating...\"}\r\n            </>\r\n          ) : (\r\n            <>{initialData?.id ? \"Update Account\" : \"Create Account\"}</>\r\n          )}\r\n        </Button>\r\n      </div>\r\n    </form>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\coa\\COAHierarchyView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\coa\\COASelector.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"useState"},"fix":{"range":[26,35],"text":""},"desc":"Remove unused variable \"useState\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { useState, useMemo } from \"react\";\r\nimport type { COAType } from \"../../../../generated/prisma\";\r\n\r\ninterface COASelectorOption {\r\n  id: string;\r\n  code: string;\r\n  name: string;\r\n  accountType: COAType;\r\n  category: string;\r\n  subcategory: string | null;\r\n  parentId: string | null;\r\n}\r\n\r\ninterface COASelectorProps {\r\n  accounts: COASelectorOption[];\r\n  value: string;\r\n  onChange: (accountId: string) => void;\r\n  accountType?: COAType;\r\n  placeholder?: string;\r\n  error?: string;\r\n  disabled?: boolean;\r\n  required?: boolean;\r\n  label?: string;\r\n}\r\n\r\nexport function COASelector({\r\n  accounts,\r\n  value,\r\n  onChange,\r\n  accountType,\r\n  placeholder = \"Select an account...\",\r\n  error,\r\n  disabled,\r\n  required,\r\n  label = \"Chart of Account\",\r\n}: COASelectorProps) {\r\n  // Filter by account type if specified\r\n  const filteredAccounts = useMemo(() => {\r\n    if (accountType) {\r\n      return accounts.filter((acc) => acc.accountType === accountType);\r\n    }\r\n    return accounts;\r\n  }, [accounts, accountType]);\r\n\r\n  // Group accounts by type for better organization\r\n  const groupedAccounts = useMemo(() => {\r\n    const groups: Record<COAType, COASelectorOption[]> = {\r\n      ASSET: [],\r\n      LIABILITY: [],\r\n      EQUITY: [],\r\n      REVENUE: [],\r\n      EXPENSE: [],\r\n    };\r\n\r\n    filteredAccounts.forEach((account) => {\r\n      groups[account.accountType].push(account);\r\n    });\r\n\r\n    return groups;\r\n  }, [filteredAccounts]);\r\n\r\n  // Build hierarchical display name\r\n  const buildHierarchicalName = (account: COASelectorOption): string => {\r\n    const parent = accounts.find((a) => a.id === account.parentId);\r\n    if (parent) {\r\n      return `${buildHierarchicalName(parent)} > ${account.code}`;\r\n    }\r\n    return account.code;\r\n  };\r\n\r\n  const getAccountTypeLabel = (type: COAType): string => {\r\n    const labels: Record<COAType, string> = {\r\n      ASSET: \"Assets\",\r\n      LIABILITY: \"Liabilities\",\r\n      EQUITY: \"Equity\",\r\n      REVENUE: \"Revenue\",\r\n      EXPENSE: \"Expenses\",\r\n    };\r\n    return labels[type];\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {label && (\r\n        <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n          {label} {required && <span className=\"text-red-500\">*</span>}\r\n        </label>\r\n      )}\r\n      \r\n      <select\r\n        value={value}\r\n        onChange={(e) => onChange(e.target.value)}\r\n        disabled={disabled}\r\n        className={`w-full rounded-lg border px-4 py-2 text-sm focus:outline-none focus:ring-2 ${\r\n          error\r\n            ? \"border-red-500 focus:ring-red-500\"\r\n            : \"border-gray-300 focus:ring-blue-500\"\r\n        } ${disabled ? \"bg-gray-100 cursor-not-allowed\" : \"bg-white\"}`}\r\n      >\r\n        <option value=\"\">{placeholder}</option>\r\n        \r\n        {accountType ? (\r\n          // Single type view - flat list\r\n          filteredAccounts.map((account) => (\r\n            <option key={account.id} value={account.id}>\r\n              {buildHierarchicalName(account)} - {account.name}\r\n              {account.subcategory && ` (${account.subcategory})`}\r\n            </option>\r\n          ))\r\n        ) : (\r\n          // All types view - grouped by type\r\n          Object.entries(groupedAccounts).map(([type, typeAccounts]) => {\r\n            if (typeAccounts.length === 0) return null;\r\n            return (\r\n              <optgroup key={type} label={getAccountTypeLabel(type as COAType)}>\r\n                {typeAccounts.map((account) => (\r\n                  <option key={account.id} value={account.id}>\r\n                    {buildHierarchicalName(account)} - {account.name}\r\n                    {account.subcategory && ` (${account.subcategory})`}\r\n                  </option>\r\n                ))}\r\n              </optgroup>\r\n            );\r\n          })\r\n        )}\r\n      </select>\r\n\r\n      {error && <p className=\"mt-1 text-sm text-red-600\">{error}</p>}\r\n      \r\n      {!error && accountType && (\r\n        <p className=\"mt-1 text-xs text-gray-500\">\r\n          Showing {filteredAccounts.length} {accountType.toLowerCase()} account(s)\r\n        </p>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\features\\coa\\COATable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\layouts\\AppShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\navigation\\Breadcrumbs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\navigation\\SidebarNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\navigation\\TopHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\ui\\Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\components\\ui\\Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\env.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\lib\\api\\rest-utils.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-imports","severity":1,"message":"Imports \"NextRequest\" are only used as type.","line":1,"column":1,"nodeType":"ImportDeclaration","messageId":"someImportsAreOnlyTypes","endLine":1,"endColumn":57,"fix":{"range":[9,20],"text":"type NextRequest"}},{"ruleId":"@typescript-eslint/consistent-type-imports","severity":1,"message":"Imports \"z\" are only used as type.","line":2,"column":1,"nodeType":"ImportDeclaration","messageId":"someImportsAreOnlyTypes","endLine":2,"endColumn":35,"fix":{"range":[67,68],"text":"type z"}},{"ruleId":"@typescript-eslint/consistent-type-imports","severity":1,"message":"All imports in the declaration are only used as types. Use `import type`.","line":4,"column":1,"nodeType":"ImportDeclaration","messageId":"typeOverValue","endLine":4,"endColumn":50,"fix":{"range":[142,146],"text":"type Role"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[252,255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[252,255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[362,365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[362,365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type string trivially inferred from a string literal, remove type annotation.","line":26,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":26,"endColumn":34,"fix":{"range":[567,575],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":27,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":27,"endColumn":23,"fix":{"range":[605,613],"text":""}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[634,637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[634,637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":36,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":36,"endColumn":16},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":47,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":47,"endColumn":23,"fix":{"range":[958,966],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type string trivially inferred from a string literal, remove type annotation.","line":74,"column":12,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":74,"endColumn":43,"fix":{"range":[1497,1505],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":75,"column":12,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":75,"endColumn":32,"fix":{"range":[1544,1552],"text":""}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1582,1585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1582,1585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":105,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":105,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4098,4101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4098,4101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4982,4985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4982,4985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5066,5069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5066,5069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5399,5402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5399,5402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":223,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5511,5514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5511,5514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":225,"column":40,"nodeType":"Property","messageId":"anyAssignment","endLine":225,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .params on an `any` value.","line":225,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":225,"endColumn":68},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5872,5875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5872,5875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":244,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6152,6155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6152,6155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":245,"column":3,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":245,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .params on an `any` value.","line":245,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":245,"endColumn":25},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":245,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":245,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[6209,6211],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":257,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":257,"endColumn":28,"fix":{"range":[6416,6424],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":258,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":258,"endColumn":25,"fix":{"range":[6442,6450],"text":""}}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":7,"fixableWarningCount":3,"source":"import { NextRequest, NextResponse } from \"next/server\";\r\nimport { z, ZodError } from \"zod\";\r\nimport { auth } from \"@/server/auth\";\r\nimport { Role } from \"../../../generated/prisma\";\r\n\r\n// Standard API response format\r\nexport interface ApiResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: {\r\n    code: string;\r\n    message: string;\r\n    details?: any;\r\n  };\r\n  meta?: {\r\n    page?: number;\r\n    limit?: number;\r\n    total?: number;\r\n    hasMore?: boolean;\r\n  };\r\n}\r\n\r\n// Error response helper\r\nexport function errorResponse(\r\n  message: string,\r\n  code: string = \"INTERNAL_ERROR\",\r\n  status: number = 500,\r\n  details?: any\r\n): NextResponse<ApiResponse> {\r\n  return NextResponse.json(\r\n    {\r\n      success: false,\r\n      error: {\r\n        code,\r\n        message,\r\n        details,\r\n      },\r\n    },\r\n    { status }\r\n  );\r\n}\r\n\r\n// Success response helper\r\nexport function successResponse<T>(\r\n  data: T,\r\n  meta?: ApiResponse[\"meta\"],\r\n  status: number = 200\r\n): NextResponse<ApiResponse<T>> {\r\n  return NextResponse.json(\r\n    {\r\n      success: true,\r\n      data,\r\n      meta,\r\n    },\r\n    { status }\r\n  );\r\n}\r\n\r\n// Get authenticated session\r\nexport async function getAuthSession(_request: NextRequest) {\r\n  const session = await auth();\r\n  \r\n  if (!session?.user) {\r\n    throw new ApiError(\"Unauthorized\", \"UNAUTHORIZED\", 401);\r\n  }\r\n  \r\n  return session;\r\n}\r\n\r\n// Custom API Error class\r\nexport class ApiError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string = \"INTERNAL_ERROR\",\r\n    public status: number = 500,\r\n    public details?: any\r\n  ) {\r\n    super(message);\r\n    this.name = \"ApiError\";\r\n  }\r\n}\r\n\r\n// Check user role\r\nexport function checkRole(userRole: Role, allowedRoles: Role[]): boolean {\r\n  return allowedRoles.includes(userRole);\r\n}\r\n\r\n// Require specific roles\r\nexport function requireRoles(userRole: Role, allowedRoles: Role[]) {\r\n  if (!checkRole(userRole, allowedRoles)) {\r\n    throw new ApiError(\r\n      \"Insufficient permissions\",\r\n      \"FORBIDDEN\",\r\n      403\r\n    );\r\n  }\r\n}\r\n\r\n// Validate request body with Zod schema\r\nexport async function validateBody<T>(\r\n  request: NextRequest,\r\n  schema: z.ZodSchema<T>\r\n): Promise<T> {\r\n  try {\r\n    const body = await request.json();\r\n    return schema.parse(body);\r\n  } catch (error) {\r\n    if (error instanceof ZodError) {\r\n      throw new ApiError(\r\n        \"Validation error\",\r\n        \"VALIDATION_ERROR\",\r\n        400,\r\n        error.issues\r\n      );\r\n    }\r\n    throw new ApiError(\"Invalid JSON body\", \"BAD_REQUEST\", 400);\r\n  }\r\n}\r\n\r\n// Parse query parameters\r\nexport function parseQuery(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams;\r\n  return {\r\n    get: (key: string) => searchParams.get(key),\r\n    getAll: (key: string) => searchParams.getAll(key),\r\n    has: (key: string) => searchParams.has(key),\r\n    getNumber: (key: string, defaultValue?: number) => {\r\n      const value = searchParams.get(key);\r\n      if (!value) return defaultValue;\r\n      const num = parseInt(value, 10);\r\n      return isNaN(num) ? defaultValue : num;\r\n    },\r\n    getBoolean: (key: string, defaultValue?: boolean) => {\r\n      const value = searchParams.get(key);\r\n      if (!value) return defaultValue;\r\n      return value === \"true\" || value === \"1\";\r\n    },\r\n    getDate: (key: string) => {\r\n      const value = searchParams.get(key);\r\n      if (!value) return undefined;\r\n      const date = new Date(value);\r\n      return isNaN(date.getTime()) ? undefined : date;\r\n    },\r\n  };\r\n}\r\n\r\n// Handle API errors uniformly\r\nexport function handleApiError(error: unknown): NextResponse<ApiResponse> {\r\n  console.error(\"API Error:\", error);\r\n\r\n  if (error instanceof ApiError) {\r\n    return errorResponse(error.message, error.code, error.status, error.details);\r\n  }\r\n\r\n  if (error instanceof ZodError) {\r\n    return errorResponse(\r\n      \"Validation error\",\r\n      \"VALIDATION_ERROR\",\r\n      400,\r\n      error.issues\r\n    );\r\n  }\r\n\r\n  // Prisma errors\r\n  if (error && typeof error === \"object\" && \"code\" in error) {\r\n    const prismaError = error as { code: string; meta?: any };\r\n    \r\n    switch (prismaError.code) {\r\n      case \"P2002\":\r\n        return errorResponse(\r\n          \"A record with this value already exists\",\r\n          \"DUPLICATE_ENTRY\",\r\n          409\r\n        );\r\n      case \"P2025\":\r\n        return errorResponse(\r\n          \"Record not found\",\r\n          \"NOT_FOUND\",\r\n          404\r\n        );\r\n      case \"P2003\":\r\n        return errorResponse(\r\n          \"Foreign key constraint failed\",\r\n          \"FOREIGN_KEY_ERROR\",\r\n          400\r\n        );\r\n      default:\r\n        return errorResponse(\r\n          \"Database error\",\r\n          \"DATABASE_ERROR\",\r\n          500\r\n        );\r\n    }\r\n  }\r\n\r\n  return errorResponse(\r\n    \"An unexpected error occurred\",\r\n    \"INTERNAL_ERROR\",\r\n    500\r\n  );\r\n}\r\n\r\n// Wrapper for API route handlers with error handling\r\nexport function withErrorHandler(\r\n  handler: (request: NextRequest, context?: any) => Promise<NextResponse>\r\n) {\r\n  return async (request: NextRequest, context?: any) => {\r\n    try {\r\n      return await handler(request, context);\r\n    } catch (error) {\r\n      return handleApiError(error);\r\n    }\r\n  };\r\n}\r\n\r\n// Wrapper for authenticated API routes\r\nexport function withAuth(\r\n  handler: (\r\n    request: NextRequest,\r\n    context: { session: Awaited<ReturnType<typeof getAuthSession>>; params?: any }\r\n  ) => Promise<NextResponse>\r\n) {\r\n  return withErrorHandler(async (request: NextRequest, routeContext?: any) => {\r\n    const session = await getAuthSession(request);\r\n    return handler(request, { session, params: routeContext?.params });\r\n  });\r\n}\r\n\r\n// Wrapper for role-protected API routes\r\nexport function withRoles(\r\n  allowedRoles: Role[],\r\n  handler: (\r\n    request: NextRequest,\r\n    context: { session: Awaited<ReturnType<typeof getAuthSession>>; params?: any }\r\n  ) => Promise<NextResponse>\r\n) {\r\n  return withAuth(async (request, context) => {\r\n    requireRoles(context.session.user.role, allowedRoles);\r\n    return handler(request, context);\r\n  });\r\n}\r\n\r\n// Extract route params from context\r\nexport function getRouteParams(context: any): Record<string, string> {\r\n  return context?.params || {};\r\n}\r\n\r\n// Pagination helpers\r\nexport interface PaginationParams {\r\n  page: number;\r\n  limit: number;\r\n  skip: number;\r\n}\r\n\r\nexport function getPaginationParams(\r\n  request: NextRequest,\r\n  defaultLimit: number = 50,\r\n  maxLimit: number = 100\r\n): PaginationParams {\r\n  const query = parseQuery(request);\r\n  const page = Math.max(1, query.getNumber(\"page\", 1) ?? 1);\r\n  const limit = Math.min(\r\n    maxLimit,\r\n    Math.max(1, query.getNumber(\"limit\", defaultLimit) ?? defaultLimit)\r\n  );\r\n  const skip = (page - 1) * limit;\r\n\r\n  return { page, limit, skip };\r\n}\r\n\r\nexport function createPaginationMeta(\r\n  page: number,\r\n  limit: number,\r\n  total: number\r\n): ApiResponse[\"meta\"] {\r\n  return {\r\n    page,\r\n    limit,\r\n    total,\r\n    hasMore: page * limit < total,\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\lib\\auth\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\lib\\constants\\roles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\lib\\constants\\status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\lib\\utils\\format.ts","messages":[{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type string trivially inferred from a string literal, remove type annotation.","line":10,"column":3,"nodeType":"AssignmentPattern","messageId":"noInferrableType","endLine":10,"endColumn":27,"fix":{"range":[162,170],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * Format utilities for the Travel & Claim System\r\n */\r\n\r\n/**\r\n * Format currency amount\r\n */\r\nexport function formatCurrency(\r\n  amount: number,\r\n  currency: string = \"USD\"\r\n): string {\r\n  return new Intl.NumberFormat(\"en-US\", {\r\n    style: \"currency\",\r\n    currency,\r\n  }).format(amount);\r\n}\r\n\r\n/**\r\n * Format date to readable string\r\n */\r\nexport function formatDate(date: Date | string): string {\r\n  const d = typeof date === \"string\" ? new Date(date) : date;\r\n  return new Intl.DateTimeFormat(\"en-US\", {\r\n    year: \"numeric\",\r\n    month: \"short\",\r\n    day: \"numeric\",\r\n  }).format(d);\r\n}\r\n\r\n/**\r\n * Format date and time\r\n */\r\nexport function formatDateTime(date: Date | string): string {\r\n  const d = typeof date === \"string\" ? new Date(date) : date;\r\n  return new Intl.DateTimeFormat(\"en-US\", {\r\n    year: \"numeric\",\r\n    month: \"short\",\r\n    day: \"numeric\",\r\n    hour: \"2-digit\",\r\n    minute: \"2-digit\",\r\n  }).format(d);\r\n}\r\n\r\n/**\r\n * Format relative time (e.g., \"2 hours ago\")\r\n */\r\nexport function formatRelativeTime(date: Date | string): string {\r\n  const d = typeof date === \"string\" ? new Date(date) : date;\r\n  const now = new Date();\r\n  const diffInSeconds = Math.floor((now.getTime() - d.getTime()) / 1000);\r\n\r\n  if (diffInSeconds < 60) {\r\n    return \"just now\";\r\n  }\r\n\r\n  const diffInMinutes = Math.floor(diffInSeconds / 60);\r\n  if (diffInMinutes < 60) {\r\n    return `${diffInMinutes} ${diffInMinutes === 1 ? \"minute\" : \"minutes\"} ago`;\r\n  }\r\n\r\n  const diffInHours = Math.floor(diffInMinutes / 60);\r\n  if (diffInHours < 24) {\r\n    return `${diffInHours} ${diffInHours === 1 ? \"hour\" : \"hours\"} ago`;\r\n  }\r\n\r\n  const diffInDays = Math.floor(diffInHours / 24);\r\n  if (diffInDays < 30) {\r\n    return `${diffInDays} ${diffInDays === 1 ? \"day\" : \"days\"} ago`;\r\n  }\r\n\r\n  const diffInMonths = Math.floor(diffInDays / 30);\r\n  if (diffInMonths < 12) {\r\n    return `${diffInMonths} ${diffInMonths === 1 ? \"month\" : \"months\"} ago`;\r\n  }\r\n\r\n  const diffInYears = Math.floor(diffInMonths / 12);\r\n  return `${diffInYears} ${diffInYears === 1 ? \"year\" : \"years\"} ago`;\r\n}\r\n\r\n/**\r\n * Format file size\r\n */\r\nexport function formatFileSize(bytes: number): string {\r\n  if (bytes === 0) return \"0 Bytes\";\r\n\r\n  const k = 1024;\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\r\n}\r\n\r\n/**\r\n * Truncate text with ellipsis\r\n */\r\nexport function truncate(text: string, maxLength: number): string {\r\n  if (text.length <= maxLength) return text;\r\n  return text.slice(0, maxLength - 3) + \"...\";\r\n}\r\n\r\n/**\r\n * Generate initials from name\r\n */\r\nexport function getInitials(name: string): string {\r\n  return name\r\n    .split(\" \")\r\n    .map((n) => n[0])\r\n    .join(\"\")\r\n    .toUpperCase()\r\n    .slice(0, 2);\r\n}\r\n\r\n/**\r\n * Combine class names\r\n */\r\nexport function cn(...classes: (string | undefined | null | false)[]): string {\r\n  return classes.filter(Boolean).join(\" \");\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\root.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\approval.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1187,1190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1187,1190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":49,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .travelRequestId on an `any` value.","line":53,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .claimId on an `any` value.","line":55,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":55,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":61,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":61,"endColumn":14}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport {\r\n  ApprovalStatus,\r\n  TravelStatus,\r\n  ClaimStatus,\r\n  AuditAction,\r\n  ApprovalLevel,\r\n} from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  supervisorProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const approvalRouter = createTRPCRouter({\r\n  // Get all approvals for current user\r\n  getMyApprovals: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/approvals/my',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Get my approvals',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"list_my_approvals\",\r\n        description: \"List all pending and historical approvals assigned to the current supervisor/manager\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        status: z.nativeEnum(ApprovalStatus).optional(),\r\n        entityType: z.enum([\"TravelRequest\", \"Claim\"]).optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        approverId: ctx.session.user.id,\r\n      };\r\n\r\n      if (input?.status) {\r\n        where.status = input.status;\r\n      }\r\n\r\n      if (input?.entityType === \"TravelRequest\") {\r\n        where.travelRequestId = { not: null };\r\n      } else if (input?.entityType === \"Claim\") {\r\n        where.claimId = { not: null };\r\n      }\r\n\r\n      const approvals = await ctx.db.approval.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              requester: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                  employeeId: true,\r\n                  department: {\r\n                    select: {\r\n                      name: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n          claim: {\r\n            include: {\r\n              submitter: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                  employeeId: true,\r\n                },\r\n              },\r\n              travelRequest: {\r\n                select: {\r\n                  requestNumber: true,\r\n                  destination: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          approver: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (approvals.length > limit) {\r\n        const nextItem = approvals.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        approvals,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get pending approvals count\r\n  getPendingCount: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/approvals/pending-count',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Get pending approvals count',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"get_pending_approvals_count\",\r\n        description: \"Get the number of pending approvals waiting for the current user's action\",\r\n      },\r\n    })\r\n    .input(z.object({}))\r\n    .output(z.number())\r\n    .query(async ({ ctx }) => {\r\n    return ctx.db.approval.count({\r\n      where: {\r\n        approverId: ctx.session.user.id,\r\n        status: ApprovalStatus.PENDING,\r\n      },\r\n    });\r\n  }),\r\n\r\n  // Get approval by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/approvals/{id}',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Get approval by ID',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"get_approval_by_id\",\r\n        description: \"Get detailed information about a specific approval by its ID\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              requester: {\r\n                include: {\r\n                  department: true,\r\n                  supervisor: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                      email: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n              participants: {\r\n                include: {\r\n                  user: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                      email: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n              approvals: {\r\n                include: {\r\n                  approver: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                      role: true,\r\n                    },\r\n                  },\r\n                },\r\n                orderBy: {\r\n                  createdAt: \"asc\",\r\n                },\r\n              },\r\n            },\r\n          },\r\n          claim: {\r\n            include: {\r\n              submitter: {\r\n                include: {\r\n                  department: true,\r\n                },\r\n              },\r\n              travelRequest: {\r\n                include: {\r\n                  requester: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                      email: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n              attachments: true,\r\n              approvals: {\r\n                include: {\r\n                  approver: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                      role: true,\r\n                    },\r\n                  },\r\n                },\r\n                orderBy: {\r\n                  createdAt: \"asc\",\r\n                },\r\n              },\r\n            },\r\n          },\r\n          approver: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!approval) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isApprover = approval.approverId === ctx.session.user.id;\r\n      const isRequester =\r\n        approval.travelRequest?.requesterId === ctx.session.user.id ||\r\n        approval.claim?.submitterId === ctx.session.user.id;\r\n      const canView = [\"MANAGER\", \"DIRECTOR\", \"ADMIN\", \"FINANCE\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isApprover && !isRequester && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this approval\",\r\n        });\r\n      }\r\n\r\n      return approval;\r\n    }),\r\n\r\n  // Approve travel request\r\n  approveTravelRequest: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/approve-travel-request',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Approve travel request',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"approve_travel_request\",\r\n        description: \"Approve a travel request approval at the current supervisor/manager level\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        comments: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              approvals: {\r\n                orderBy: {\r\n                  level: \"asc\",\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to approve this request\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.APPROVED,\r\n          comments: input.comments,\r\n          approvedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Check if all previous level approvals are complete\r\n      const currentLevelIndex = Object.values(ApprovalLevel).indexOf(approval.level);\r\n      const allPreviousApproved = approval.travelRequest.approvals\r\n        .filter((a) => {\r\n          const levelIndex = Object.values(ApprovalLevel).indexOf(a.level);\r\n          return levelIndex < currentLevelIndex;\r\n        })\r\n        .every((a) => a.status === ApprovalStatus.APPROVED);\r\n\r\n      if (!allPreviousApproved) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Previous level approvals must be completed first\",\r\n        });\r\n      }\r\n\r\n      // Check if there are more approvals pending\r\n      const pendingApprovals = approval.travelRequest.approvals.filter(\r\n        (a) => a.status === ApprovalStatus.PENDING\r\n      );\r\n\r\n      // Determine new status\r\n      let newStatus: TravelStatus;\r\n      if (pendingApprovals.length === 1 && pendingApprovals[0]!.id === input.approvalId) {\r\n        // This is the last approval\r\n        newStatus = TravelStatus.APPROVED;\r\n      } else {\r\n        // Map approval level to travel status\r\n        const statusMap: Record<ApprovalLevel, TravelStatus> = {\r\n          [ApprovalLevel.L1_SUPERVISOR]: TravelStatus.APPROVED_L1,\r\n          [ApprovalLevel.L2_MANAGER]: TravelStatus.APPROVED_L2,\r\n          [ApprovalLevel.L3_DIRECTOR]: TravelStatus.APPROVED_L3,\r\n          [ApprovalLevel.L4_SENIOR_DIRECTOR]: TravelStatus.APPROVED_L4,\r\n          [ApprovalLevel.L5_EXECUTIVE]: TravelStatus.APPROVED_L5,\r\n        };\r\n        newStatus = statusMap[approval.level] || TravelStatus.SUBMITTED;\r\n      }\r\n\r\n      // Update travel request status\r\n      await ctx.db.travelRequest.update({\r\n        where: { id: approval.travelRequestId! },\r\n        data: {\r\n          status: newStatus,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.APPROVE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: approval.travelRequestId!,\r\n          metadata: {\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            comments: input.comments,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to requester\r\n\r\n      return updatedApproval;\r\n    }),\r\n\r\n  // Reject travel request\r\n  rejectTravelRequest: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/reject-travel-request',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Reject travel request',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"reject_travel_request\",\r\n        description: \"Reject a travel request with a mandatory rejection reason\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        rejectionReason: z.string().min(10),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          travelRequest: true,\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to reject this request\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.REJECTED,\r\n          rejectionReason: input.rejectionReason,\r\n          rejectedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Update travel request status\r\n      await ctx.db.travelRequest.update({\r\n        where: { id: approval.travelRequestId! },\r\n        data: {\r\n          status: TravelStatus.REJECTED,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.REJECT,\r\n          entityType: \"TravelRequest\",\r\n          entityId: approval.travelRequestId!,\r\n          metadata: {\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            rejectionReason: input.rejectionReason,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to requester\r\n\r\n      return updatedApproval;\r\n    }),\r\n\r\n  // Request revision for travel request\r\n  requestRevision: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/request-revision',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Request revision for travel request',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"request_travel_request_revision\",\r\n        description: \"Request a revision for a travel request, resetting all approvals back to pending\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        comments: z.string().min(10),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          travelRequest: true,\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to request revision for this request\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.REVISION_REQUESTED,\r\n          comments: input.comments,\r\n        },\r\n      });\r\n\r\n      // Reset all approvals to pending\r\n      await ctx.db.approval.updateMany({\r\n        where: {\r\n          travelRequestId: approval.travelRequestId,\r\n        },\r\n        data: {\r\n          status: ApprovalStatus.PENDING,\r\n          approvedAt: null,\r\n          rejectedAt: null,\r\n        },\r\n      });\r\n\r\n      // Update travel request status\r\n      await ctx.db.travelRequest.update({\r\n        where: { id: approval.travelRequestId! },\r\n        data: {\r\n          status: TravelStatus.REVISION,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: approval.travelRequestId!,\r\n          metadata: {\r\n            action: \"revision_requested\",\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            comments: input.comments,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to requester\r\n\r\n      return updatedApproval;\r\n    }),\r\n\r\n  // Approve claim\r\n  approveClaim: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/approve-claim',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Approve claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"approve_claim\",\r\n        description: \"Approve a claim at the current supervisor/manager level\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        comments: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          claim: {\r\n            include: {\r\n              approvals: {\r\n                orderBy: {\r\n                  level: \"asc\",\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to approve this claim\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.APPROVED,\r\n          comments: input.comments,\r\n          approvedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Check if there are more approvals pending\r\n      const pendingApprovals = approval.claim.approvals.filter(\r\n        (a) => a.status === ApprovalStatus.PENDING && a.id !== input.approvalId\r\n      );\r\n\r\n      // Update claim status\r\n      const newStatus =\r\n        pendingApprovals.length === 0 ? ClaimStatus.APPROVED : approval.claim.status;\r\n\r\n      await ctx.db.claim.update({\r\n        where: { id: approval.claimId! },\r\n        data: {\r\n          status: newStatus,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.APPROVE,\r\n          entityType: \"Claim\",\r\n          entityId: approval.claimId!,\r\n          metadata: {\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            comments: input.comments,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to submitter\r\n\r\n      return updatedApproval;\r\n    }),\r\n\r\n  // Reject claim\r\n  rejectClaim: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/reject-claim',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Reject claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"reject_claim\",\r\n        description: \"Reject a claim with a mandatory rejection reason\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        rejectionReason: z.string().min(10),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          claim: true,\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to reject this claim\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.REJECTED,\r\n          rejectionReason: input.rejectionReason,\r\n          rejectedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Update claim status\r\n      await ctx.db.claim.update({\r\n        where: { id: approval.claimId! },\r\n        data: {\r\n          status: ClaimStatus.REJECTED,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.REJECT,\r\n          entityType: \"Claim\",\r\n          entityId: approval.claimId!,\r\n          metadata: {\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            rejectionReason: input.rejectionReason,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to submitter\r\n\r\n      return updatedApproval;\r\n    }),\r\n\r\n  // Request revision for claim\r\n  requestClaimRevision: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/approvals/{approvalId}/request-claim-revision',\r\n        protect: true,\r\n        tags: ['Approvals'],\r\n        summary: 'Request revision for claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"request_claim_revision\",\r\n        description: \"Request a revision for a claim, resetting all approvals back to pending\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        approvalId: z.string(),\r\n        comments: z.string().min(10),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const approval = await ctx.db.approval.findUnique({\r\n        where: { id: input.approvalId },\r\n        include: {\r\n          claim: true,\r\n        },\r\n      });\r\n\r\n      if (!approval || !approval.claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Approval not found\",\r\n        });\r\n      }\r\n\r\n      if (approval.approverId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to request revision for this claim\",\r\n        });\r\n      }\r\n\r\n      if (approval.status !== ApprovalStatus.PENDING) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"This approval has already been processed\",\r\n        });\r\n      }\r\n\r\n      // Update approval\r\n      const updatedApproval = await ctx.db.approval.update({\r\n        where: { id: input.approvalId },\r\n        data: {\r\n          status: ApprovalStatus.REVISION_REQUESTED,\r\n          comments: input.comments,\r\n        },\r\n      });\r\n\r\n      // Reset all approvals to pending\r\n      await ctx.db.approval.updateMany({\r\n        where: {\r\n          claimId: approval.claimId,\r\n        },\r\n        data: {\r\n          status: ApprovalStatus.PENDING,\r\n          approvedAt: null,\r\n          rejectedAt: null,\r\n        },\r\n      });\r\n\r\n      // Update claim status\r\n      await ctx.db.claim.update({\r\n        where: { id: approval.claimId! },\r\n        data: {\r\n          status: ClaimStatus.REVISION,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"Claim\",\r\n          entityId: approval.claimId!,\r\n          metadata: {\r\n            action: \"revision_requested\",\r\n            approvalId: input.approvalId,\r\n            level: approval.level,\r\n            comments: input.comments,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Send notification to submitter\r\n\r\n      return updatedApproval;\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\attachment.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":242,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":242,"endColumn":51}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { AuditAction } from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const attachmentRouter = createTRPCRouter({\r\n  // Get attachments by claim ID\r\n  getByClaim: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/attachments/by-claim/{claimId}',\r\n        protect: true,\r\n        tags: ['Attachments'],\r\n        summary: 'Get attachments by claim ID',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"list_claim_attachments\",\r\n        description: \"List all attachments for a specific claim\",\r\n      },\r\n    })\r\n    .input(z.object({ claimId: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Verify access to claim\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.claimId },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              participants: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isSubmitter = claim.submitterId === ctx.session.user.id;\r\n      const isRequester = claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view attachments for this claim\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.attachment.findMany({\r\n        where: {\r\n          claimId: input.claimId,\r\n          deletedAt: null,\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get attachment by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/attachments/{id}',\r\n        protect: true,\r\n        tags: ['Attachments'],\r\n        summary: 'Get attachment by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const attachment = await ctx.db.attachment.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          claim: {\r\n            include: {\r\n              submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n              travelRequest: {\r\n                include: {\r\n                  requester: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, image: true } },\r\n                  participants: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!attachment) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Attachment not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isSubmitter = attachment.claim.submitterId === ctx.session.user.id;\r\n      const isRequester = attachment.claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = attachment.claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this attachment\",\r\n        });\r\n      }\r\n\r\n      return attachment;\r\n    }),\r\n\r\n  // Create attachment metadata (actual file upload would be handled separately via upload endpoint)\r\n  create: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/attachments',\r\n        protect: true,\r\n        tags: ['Attachments'],\r\n        summary: 'Create attachment metadata',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"add_claim_attachment\",\r\n        description: \"Add an attachment to a claim with metadata\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        claimId: z.string(),\r\n        filename: z.string(),\r\n        originalName: z.string(),\r\n        mimeType: z.string(),\r\n        fileSize: z.number().positive(),\r\n        storageUrl: z.string(),\r\n        storageProvider: z.string().default(\"local\"),\r\n        ocrExtractedData: z.any().optional(),\r\n        ocrConfidence: z.number().min(0).max(100).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Verify claim exists and user has access\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.claimId },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              participants: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Check if user can add attachments to this claim\r\n      const isSubmitter = claim.submitterId === ctx.session.user.id;\r\n      const isRequester = claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to add attachments to this claim\",\r\n        });\r\n      }\r\n\r\n      // Can only add attachments to DRAFT or REVISION claims\r\n      if (![\"DRAFT\", \"REVISION\"].includes(claim.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only add attachments to claims in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      // Validate file size (max 10MB)\r\n      const maxSize = 10 * 1024 * 1024; // 10MB\r\n      if (input.fileSize > maxSize) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"File size exceeds maximum allowed size of 10MB\",\r\n        });\r\n      }\r\n\r\n      // Validate mime type (allow images and PDFs)\r\n      const allowedTypes = [\r\n        \"image/jpeg\",\r\n        \"image/jpg\",\r\n        \"image/png\",\r\n        \"image/gif\",\r\n        \"image/webp\",\r\n        \"application/pdf\",\r\n      ];\r\n\r\n      if (!allowedTypes.includes(input.mimeType)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"File type not allowed. Only images and PDFs are accepted\",\r\n        });\r\n      }\r\n\r\n      const attachment = await ctx.db.attachment.create({\r\n        data: {\r\n          claimId: input.claimId,\r\n          filename: input.filename,\r\n          originalName: input.originalName,\r\n          mimeType: input.mimeType,\r\n          fileSize: input.fileSize,\r\n          storageUrl: input.storageUrl,\r\n          storageProvider: input.storageProvider,\r\n          ocrExtractedData: input.ocrExtractedData,\r\n          ocrConfidence: input.ocrConfidence,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"Attachment\",\r\n          entityId: attachment.id,\r\n          metadata: {\r\n            claimId: input.claimId,\r\n            filename: input.filename,\r\n            fileSize: input.fileSize,\r\n          },\r\n        },\r\n      });\r\n\r\n      return attachment;\r\n    }),\r\n\r\n  // Update attachment metadata (e.g., OCR data)\r\n  update: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PATCH',\r\n        path: '/attachments/{id}',\r\n        protect: true,\r\n        tags: ['Attachments'],\r\n        summary: 'Update attachment metadata',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        ocrExtractedData: z.any().optional(),\r\n        ocrConfidence: z.number().min(0).max(100).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      const attachment = await ctx.db.attachment.findUnique({\r\n        where: { id },\r\n        include: {\r\n          claim: {\r\n            include: {\r\n              submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!attachment) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Attachment not found\",\r\n        });\r\n      }\r\n\r\n      // Only claim submitter or admin can update\r\n      const canUpdate =\r\n        attachment.claim.submitterId === ctx.session.user.id ||\r\n        ctx.session.user.role === \"ADMIN\";\r\n\r\n      if (!canUpdate) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to update this attachment\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.attachment.update({\r\n        where: { id },\r\n        data: updateData,\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"Attachment\",\r\n          entityId: id,\r\n          metadata: {\r\n            updates: updateData,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Delete attachment (soft delete)\r\n  delete: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'DELETE',\r\n        path: '/attachments/{id}',\r\n        protect: true,\r\n        tags: ['Attachments'],\r\n        summary: 'Delete attachment',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"delete_claim_attachment\",\r\n        description: \"Delete an attachment from a claim\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const attachment = await ctx.db.attachment.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          claim: {\r\n            include: {\r\n              submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!attachment) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Attachment not found\",\r\n        });\r\n      }\r\n\r\n      // Only claim submitter or admin can delete\r\n      const canDelete =\r\n        attachment.claim.submitterId === ctx.session.user.id ||\r\n        ctx.session.user.role === \"ADMIN\";\r\n\r\n      if (!canDelete) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to delete this attachment\",\r\n        });\r\n      }\r\n\r\n      // Can only delete attachments from DRAFT or REVISION claims\r\n      if (![\"DRAFT\", \"REVISION\"].includes(attachment.claim.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only delete attachments from claims in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.attachment.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.DELETE,\r\n          entityType: \"Attachment\",\r\n          entityId: input.id,\r\n          metadata: {\r\n            claimId: attachment.claimId,\r\n            filename: attachment.filename,\r\n          },\r\n        },\r\n      });\r\n\r\n      // TODO: Delete actual file from storage\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Get download URL (generates a signed URL for secure download)\r\n  getDownloadUrl: protectedProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.object({\r\n      url: z.string(),\r\n      filename: z.string(),\r\n      mimeType: z.string(),\r\n      expiresIn: z.number(),\r\n    }))\r\n    .query(async ({ ctx, input }) => {\r\n      const attachment = await ctx.db.attachment.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          claim: {\r\n            include: {\r\n              travelRequest: {\r\n                include: {\r\n                  participants: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!attachment) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Attachment not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isSubmitter = attachment.claim.submitterId === ctx.session.user.id;\r\n      const isRequester = attachment.claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = attachment.claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to download this attachment\",\r\n        });\r\n      }\r\n\r\n      // TODO: Generate signed URL for secure download\r\n      // For now, return the storage URL directly\r\n      // In production, you would generate a time-limited signed URL\r\n      return {\r\n        url: attachment.storageUrl,\r\n        filename: attachment.originalName,\r\n        mimeType: attachment.mimeType,\r\n        expiresIn: 3600, // 1 hour\r\n      };\r\n    }),\r\n\r\n  // Batch create attachments\r\n  createBatch: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        claimId: z.string(),\r\n        attachments: z.array(\r\n          z.object({\r\n            filename: z.string(),\r\n            originalName: z.string(),\r\n            mimeType: z.string(),\r\n            fileSize: z.number().positive(),\r\n            storageUrl: z.string(),\r\n            storageProvider: z.string().default(\"local\"),\r\n          })\r\n        ),\r\n      })\r\n    )\r\n    .output(z.object({ count: z.number() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Verify claim\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.claimId },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              participants: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Check authorization\r\n      const isSubmitter = claim.submitterId === ctx.session.user.id;\r\n      const isRequester = claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to add attachments to this claim\",\r\n        });\r\n      }\r\n\r\n      // Check claim status\r\n      if (![\"DRAFT\", \"REVISION\"].includes(claim.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only add attachments to claims in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      // Validate all files\r\n      const maxSize = 10 * 1024 * 1024; // 10MB\r\n      const allowedTypes = [\r\n        \"image/jpeg\",\r\n        \"image/jpg\",\r\n        \"image/png\",\r\n        \"image/gif\",\r\n        \"image/webp\",\r\n        \"application/pdf\",\r\n      ];\r\n\r\n      for (const file of input.attachments) {\r\n        if (file.fileSize > maxSize) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: `File ${file.originalName} exceeds maximum size of 10MB`,\r\n          });\r\n        }\r\n\r\n        if (!allowedTypes.includes(file.mimeType)) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: `File ${file.originalName} has invalid type. Only images and PDFs are allowed`,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Create attachments\r\n      const created = await ctx.db.attachment.createMany({\r\n        data: input.attachments.map((file) => ({\r\n          claimId: input.claimId,\r\n          ...file,\r\n        })),\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"Attachment\",\r\n          entityId: input.claimId,\r\n          metadata: {\r\n            action: \"batch_create\",\r\n            count: created.count,\r\n            claimId: input.claimId,\r\n          },\r\n        },\r\n      });\r\n\r\n      return {\r\n        count: created.count,\r\n      };\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\auditLog.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1077,1080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1077,1080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":41,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":41,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .action on an `any` value.","line":45,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":49,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":49,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityId on an `any` value.","line":53,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":53,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":57,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":57,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":59,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":59,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":59,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":59,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":62,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":62,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":62,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":62,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":69,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":69,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5591,5594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5591,5594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .action on an `any` value.","line":222,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":222,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":226,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":226,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":230,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":230,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":232,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":232,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":232,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":232,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":235,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":235,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":235,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":235,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":242,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":242,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10584,10587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10584,10587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":402,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":402,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":409,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":409,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":437,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11459,11462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11459,11462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":440,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":440,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":444,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":444,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":446,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":446,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":446,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":446,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":449,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":449,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":449,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":449,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":454,"column":33,"nodeType":"Property","messageId":"anyAssignment","endLine":454,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":567,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":567,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14832,14835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14832,14835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .userId on an `any` value.","line":570,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":570,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entityType on an `any` value.","line":574,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":574,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .action on an `any` value.","line":578,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":578,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":582,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":582,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":584,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":584,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":584,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":584,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":587,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":587,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":587,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":587,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":592,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":592,"endColumn":14}],"suppressedMessages":[],"errorCount":41,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { AuditAction } from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  managerProcedure,\r\n  adminProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const auditLogRouter = createTRPCRouter({\r\n  // Get all audit logs (admin/manager only)\r\n  getAll: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/audit-logs',\r\n        protect: true,\r\n        tags: ['Audit Logs'],\r\n        summary: 'Get all audit logs',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        userId: z.string().optional(),\r\n        action: z.nativeEnum(AuditAction).optional(),\r\n        entityType: z.string().optional(),\r\n        entityId: z.string().optional(),\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.userId) {\r\n        where.userId = input.userId;\r\n      }\r\n\r\n      if (input?.action) {\r\n        where.action = input.action;\r\n      }\r\n\r\n      if (input?.entityType) {\r\n        where.entityType = input.entityType;\r\n      }\r\n\r\n      if (input?.entityId) {\r\n        where.entityId = input.entityId;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const logs = await ctx.db.auditLog.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (logs.length > limit) {\r\n        const nextItem = logs.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        logs,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get audit log by ID\r\n  getById: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/audit-logs/{id}',\r\n        protect: true,\r\n        tags: ['Audit Logs'],\r\n        summary: 'Get audit log by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const log = await ctx.db.auditLog.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              role: true,\r\n              department: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!log) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Audit log not found\",\r\n        });\r\n      }\r\n\r\n      return log;\r\n    }),\r\n\r\n  // Get audit logs for specific entity\r\n  getByEntity: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/audit-logs/by-entity',\r\n        protect: true,\r\n        tags: ['Audit Logs'],\r\n        summary: 'Get audit logs for specific entity',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        entityType: z.string(),\r\n        entityId: z.string(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Check if user has access to view this entity's audit logs\r\n      // For now, only managers and above can view entity audit logs\r\n      if (![\"MANAGER\", \"DIRECTOR\", \"ADMIN\", \"FINANCE\"].includes(ctx.session.user.role)) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Insufficient permissions to view audit logs\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.auditLog.findMany({\r\n        where: {\r\n          entityType: input.entityType,\r\n          entityId: input.entityId,\r\n        },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get audit logs for current user's actions\r\n  getMyActions: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/audit-logs/my-actions',\r\n        protect: true,\r\n        tags: ['Audit Logs'],\r\n        summary: 'Get my audit logs',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        action: z.nativeEnum(AuditAction).optional(),\r\n        entityType: z.string().optional(),\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        userId: ctx.session.user.id,\r\n      };\r\n\r\n      if (input?.action) {\r\n        where.action = input.action;\r\n      }\r\n\r\n      if (input?.entityType) {\r\n        where.entityType = input.entityType;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const logs = await ctx.db.auditLog.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (logs.length > limit) {\r\n        const nextItem = logs.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        logs,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get audit trail for a specific travel request\r\n  getTravelRequestTrail: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/audit-logs/travel-request/{travelRequestId}',\r\n        protect: true,\r\n        tags: ['Audit Logs'],\r\n        summary: 'Get audit trail for travel request',\r\n      }\r\n    })\r\n    .input(z.object({ travelRequestId: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Verify access to travel request\r\n      const travelRequest = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.travelRequestId },\r\n        include: {\r\n          participants: true,\r\n        },\r\n      });\r\n\r\n      if (!travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isRequester = travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"MANAGER\", \"DIRECTOR\", \"ADMIN\", \"FINANCE\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view audit trail for this travel request\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.auditLog.findMany({\r\n        where: {\r\n          entityType: \"TravelRequest\",\r\n          entityId: input.travelRequestId,\r\n        },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"asc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get audit trail for a specific claim\r\n  getClaimTrail: protectedProcedure\r\n    .input(z.object({ claimId: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Verify access to claim\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.claimId },\r\n        include: {\r\n          travelRequest: {\r\n            include: {\r\n              participants: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isSubmitter = claim.submitterId === ctx.session.user.id;\r\n      const isRequester = claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = claim.travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view audit trail for this claim\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.auditLog.findMany({\r\n        where: {\r\n          entityType: \"Claim\",\r\n          entityId: input.claimId,\r\n        },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"asc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get recent activity (for dashboards)\r\n  getRecentActivity: managerProcedure\r\n    .input(\r\n      z.object({\r\n        limit: z.number().min(1).max(100).optional(),\r\n        entityTypes: z.array(z.string()).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.entityTypes && input.entityTypes.length > 0) {\r\n        where.entityType = {\r\n          in: input.entityTypes,\r\n        };\r\n      }\r\n\r\n      return ctx.db.auditLog.findMany({\r\n        take: input?.limit ?? 20,\r\n        where,\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get audit statistics\r\n  getStatistics: adminProcedure\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        userId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.userId) {\r\n        where.userId = input.userId;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const [total, byAction, byEntityType, byUser] = await Promise.all([\r\n        ctx.db.auditLog.count({ where }),\r\n        ctx.db.auditLog.groupBy({\r\n          by: [\"action\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.auditLog.groupBy({\r\n          by: [\"entityType\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.auditLog.groupBy({\r\n          by: [\"userId\"],\r\n          where,\r\n          _count: true,\r\n          orderBy: {\r\n            _count: {\r\n              userId: \"desc\",\r\n            },\r\n          },\r\n          take: 10,\r\n        }),\r\n      ]);\r\n\r\n      // Get user details for top users\r\n      const userIds = byUser.map((item) => item.userId);\r\n      const users = await ctx.db.user.findMany({\r\n        where: {\r\n          id: { in: userIds },\r\n        },\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n          role: true,\r\n        },\r\n      });\r\n\r\n      const topUsers = byUser.map((item) => {\r\n        const user = users.find((u) => u.id === item.userId);\r\n        return {\r\n          userId: item.userId,\r\n          userName: user?.name ?? \"Unknown\",\r\n          userEmail: user?.email ?? \"\",\r\n          userRole: user?.role ?? \"EMPLOYEE\",\r\n          count: item._count,\r\n        };\r\n      });\r\n\r\n      return {\r\n        total,\r\n        byAction: byAction.map((item) => ({\r\n          action: item.action,\r\n          count: item._count,\r\n        })),\r\n        byEntityType: byEntityType.map((item) => ({\r\n          entityType: item.entityType,\r\n          count: item._count,\r\n        })),\r\n        topUsers,\r\n      };\r\n    }),\r\n\r\n  // Search audit logs\r\n  search: managerProcedure\r\n    .input(\r\n      z.object({\r\n        query: z.string().min(1),\r\n        limit: z.number().min(1).max(100).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Search in entity IDs and entity types\r\n      const logs = await ctx.db.auditLog.findMany({\r\n        take: input.limit,\r\n        where: {\r\n          OR: [\r\n            { entityId: { contains: input.query, mode: \"insensitive\" } },\r\n            { entityType: { contains: input.query, mode: \"insensitive\" } },\r\n          ],\r\n        },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      return logs;\r\n    }),\r\n\r\n  // Export audit logs (admin only)\r\n  export: adminProcedure\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        userId: z.string().optional(),\r\n        entityType: z.string().optional(),\r\n        action: z.nativeEnum(AuditAction).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.userId) {\r\n        where.userId = input.userId;\r\n      }\r\n\r\n      if (input?.entityType) {\r\n        where.entityType = input.entityType;\r\n      }\r\n\r\n      if (input?.action) {\r\n        where.action = input.action;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const logs = await ctx.db.auditLog.findMany({\r\n        where,\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      // Return data for export (would be converted to CSV/Excel on client side)\r\n      return logs.map((log) => ({\r\n        id: log.id,\r\n        timestamp: log.createdAt.toISOString(),\r\n        userId: log.userId,\r\n        userName: log.user.name,\r\n        userEmail: log.user.email,\r\n        userRole: log.user.role,\r\n        action: log.action,\r\n        entityType: log.entityType,\r\n        entityId: log.entityId,\r\n        ipAddress: log.ipAddress,\r\n        userAgent: log.userAgent,\r\n        changes: log.changes,\r\n        metadata: log.metadata,\r\n      }));\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\chartOfAccount.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1067,1070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1067,1070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accountType on an `any` value.","line":40,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":40,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isActive on an `any` value.","line":44,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":48,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":48,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .category on an `any` value.","line":52,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":52,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":58,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":58,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5268,5271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5268,5271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accountType on an `any` value.","line":213,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":213,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isActive on an `any` value.","line":217,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":217,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":222,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":222,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":275,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6918,6921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6918,6921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .accountType on an `any` value.","line":280,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":280,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":284,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":284,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7952,7955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7952,7955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .isActive on an `any` value.","line":322,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":322,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":326,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":326,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":853,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":853,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23019,23022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23019,23022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":857,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":860,"endColumn":5},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":857,"column":28,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":857,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .chartOfAccount on an `any` value.","line":857,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":857,"endColumn":45},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":862,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":862,"endColumn":42,"fix":{"range":[23236,23271],"text":"!descendant?.parentId"}},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":862,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":862,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":866,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":866,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":870,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":870,"endColumn":63}],"suppressedMessages":[],"errorCount":24,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { COAType, AuditAction } from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  adminProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const chartOfAccountRouter = createTRPCRouter({\r\n  // Get all Chart of Accounts with optional filters\r\n  getAll: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"GET\",\r\n        path: \"/chart-of-accounts\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Get all chart of accounts\",\r\n      },\r\n    })\r\n    .input(\r\n      z\r\n        .object({\r\n          accountType: z.nativeEnum(COAType).optional(),\r\n          isActive: z.boolean().optional(),\r\n          parentId: z.string().optional().nullable(),\r\n          category: z.string().optional(),\r\n          limit: z.number().min(1).max(100).optional(),\r\n          cursor: z.string().optional(),\r\n        })\r\n        .optional()\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.accountType) {\r\n        where.accountType = input.accountType;\r\n      }\r\n\r\n      if (input?.isActive !== undefined) {\r\n        where.isActive = input.isActive;\r\n      }\r\n\r\n      if (input?.parentId !== undefined) {\r\n        where.parentId = input.parentId;\r\n      }\r\n\r\n      if (input?.category) {\r\n        where.category = input.category;\r\n      }\r\n\r\n      const accounts = await ctx.db.chartOfAccount.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          parent: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n              accountType: true,\r\n            },\r\n          },\r\n          children: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n              accountType: true,\r\n              isActive: true,\r\n            },\r\n          },\r\n          createdBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          updatedBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n              children: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: [{ accountType: \"asc\" }, { code: \"asc\" }],\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (accounts.length > limit) {\r\n        const nextItem = accounts.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        accounts,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get Chart of Account by ID with full details\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"GET\",\r\n        path: \"/chart-of-accounts/{id}\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Get chart of account by ID\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const account = await ctx.db.chartOfAccount.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          parent: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n              accountType: true,\r\n              category: true,\r\n            },\r\n          },\r\n          children: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n              accountType: true,\r\n              category: true,\r\n              isActive: true,\r\n            },\r\n            orderBy: {\r\n              code: \"asc\",\r\n            },\r\n          },\r\n          createdBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n          updatedBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n              children: true,\r\n              auditLogs: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!account) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Chart of Account not found\",\r\n        });\r\n      }\r\n\r\n      return account;\r\n    }),\r\n\r\n  // Get COA hierarchy tree structure\r\n  getHierarchy: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"GET\",\r\n        path: \"/chart-of-accounts/hierarchy\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Get chart of accounts hierarchy tree\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        accountType: z.nativeEnum(COAType).optional(),\r\n        isActive: z.boolean().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        parentId: null,\r\n      };\r\n\r\n      if (input.accountType) {\r\n        where.accountType = input.accountType;\r\n      }\r\n\r\n      if (input.isActive !== undefined) {\r\n        where.isActive = input.isActive;\r\n      }\r\n\r\n      // Get root accounts (no parent) with nested children\r\n      const rootAccounts = await ctx.db.chartOfAccount.findMany({\r\n        where,\r\n        include: {\r\n          children: {\r\n            include: {\r\n              children: {\r\n                include: {\r\n                  children: {\r\n                    include: {\r\n                      children: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n              _count: {\r\n                select: {\r\n                  claims: true,\r\n                },\r\n              },\r\n            },\r\n            orderBy: {\r\n              code: \"asc\",\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: [{ accountType: \"asc\" }, { code: \"asc\" }],\r\n      });\r\n\r\n      return rootAccounts;\r\n    }),\r\n\r\n  // Get only active accounts (for dropdowns)\r\n  getActiveAccounts: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"GET\",\r\n        path: \"/chart-of-accounts/active\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Get active chart of accounts for dropdowns\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        accountType: z.nativeEnum(COAType).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        isActive: true,\r\n      };\r\n\r\n      if (input.accountType) {\r\n        where.accountType = input.accountType;\r\n      }\r\n\r\n      return ctx.db.chartOfAccount.findMany({\r\n        where,\r\n        select: {\r\n          id: true,\r\n          code: true,\r\n          name: true,\r\n          accountType: true,\r\n          category: true,\r\n          subcategory: true,\r\n          parentId: true,\r\n        },\r\n        orderBy: [{ accountType: \"asc\" }, { code: \"asc\" }],\r\n      });\r\n    }),\r\n\r\n  // Get accounts filtered by account type\r\n  getByType: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"GET\",\r\n        path: \"/chart-of-accounts/by-type/{accountType}\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Get chart of accounts by type\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        accountType: z.nativeEnum(COAType),\r\n        isActive: z.boolean().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        accountType: input.accountType,\r\n      };\r\n\r\n      if (input.isActive !== undefined) {\r\n        where.isActive = input.isActive;\r\n      }\r\n\r\n      return ctx.db.chartOfAccount.findMany({\r\n        where,\r\n        include: {\r\n          parent: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n              children: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          code: \"asc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Create new Chart of Account (Admin only)\r\n  create: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"POST\",\r\n        path: \"/chart-of-accounts\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Create chart of account (Admin only)\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        code: z\r\n          .string()\r\n          .min(1)\r\n          .max(20)\r\n          .regex(/^[A-Z0-9-]+$/, \"Code must contain only uppercase letters, numbers, and hyphens\"),\r\n        name: z.string().min(1).max(100),\r\n        accountType: z.nativeEnum(COAType),\r\n        category: z.string().min(1).max(50),\r\n        subcategory: z.string().max(50).optional(),\r\n        parentId: z.string().optional(),\r\n        description: z.string().optional(),\r\n        isActive: z.boolean().optional().default(true),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Check if code already exists\r\n      const existing = await ctx.db.chartOfAccount.findUnique({\r\n        where: { code: input.code },\r\n      });\r\n\r\n      if (existing) {\r\n        throw new TRPCError({\r\n          code: \"CONFLICT\",\r\n          message: `Account code '${input.code}' already exists`,\r\n        });\r\n      }\r\n\r\n      // Validate parent exists if provided\r\n      if (input.parentId) {\r\n        const parent = await ctx.db.chartOfAccount.findUnique({\r\n          where: { id: input.parentId },\r\n        });\r\n\r\n        if (!parent) {\r\n          throw new TRPCError({\r\n            code: \"NOT_FOUND\",\r\n            message: \"Parent account not found\",\r\n          });\r\n        }\r\n\r\n        // Validate parent has same account type\r\n        if (parent.accountType !== input.accountType) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Parent account must have the same account type\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Create the account\r\n      const account = await ctx.db.chartOfAccount.create({\r\n        data: {\r\n          code: input.code,\r\n          name: input.name,\r\n          accountType: input.accountType,\r\n          category: input.category,\r\n          subcategory: input.subcategory,\r\n          parentId: input.parentId,\r\n          description: input.description,\r\n          isActive: input.isActive ?? true,\r\n          createdById: ctx.session.user.id,\r\n          updatedById: ctx.session.user.id,\r\n        },\r\n        include: {\r\n          parent: true,\r\n          createdBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          updatedBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"ChartOfAccount\",\r\n          entityId: account.id,\r\n          chartOfAccountId: account.id,\r\n          changes: {\r\n            after: account,\r\n          },\r\n        },\r\n      });\r\n\r\n      return account;\r\n    }),\r\n\r\n  // Update existing Chart of Account (Admin only)\r\n  update: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"PUT\",\r\n        path: \"/chart-of-accounts/{id}\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Update chart of account (Admin only)\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        code: z\r\n          .string()\r\n          .min(1)\r\n          .max(20)\r\n          .regex(/^[A-Z0-9-]+$/, \"Code must contain only uppercase letters, numbers, and hyphens\")\r\n          .optional(),\r\n        name: z.string().min(1).max(100).optional(),\r\n        accountType: z.nativeEnum(COAType).optional(),\r\n        category: z.string().min(1).max(50).optional(),\r\n        subcategory: z.string().max(50).optional().nullable(),\r\n        parentId: z.string().optional().nullable(),\r\n        description: z.string().optional().nullable(),\r\n        isActive: z.boolean().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      // Check if account exists\r\n      const existing = await ctx.db.chartOfAccount.findUnique({\r\n        where: { id },\r\n        include: {\r\n          children: true,\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!existing) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Chart of Account not found\",\r\n        });\r\n      }\r\n\r\n      // If updating code, check for conflicts\r\n      if (input.code && input.code !== existing.code) {\r\n        const codeExists = await ctx.db.chartOfAccount.findUnique({\r\n          where: { code: input.code },\r\n        });\r\n\r\n        if (codeExists) {\r\n          throw new TRPCError({\r\n            code: \"CONFLICT\",\r\n            message: `Account code '${input.code}' already exists`,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Prevent circular references in parent hierarchy\r\n      if (input.parentId !== undefined) {\r\n        if (input.parentId === id) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Account cannot be its own parent\",\r\n          });\r\n        }\r\n\r\n        if (input.parentId) {\r\n          // Check if the new parent exists\r\n          const parent = await ctx.db.chartOfAccount.findUnique({\r\n            where: { id: input.parentId },\r\n          });\r\n\r\n          if (!parent) {\r\n            throw new TRPCError({\r\n              code: \"NOT_FOUND\",\r\n              message: \"Parent account not found\",\r\n            });\r\n          }\r\n\r\n          // Validate parent has same account type\r\n          const newAccountType = input.accountType ?? existing.accountType;\r\n          if (parent.accountType !== newAccountType) {\r\n            throw new TRPCError({\r\n              code: \"BAD_REQUEST\",\r\n              message: \"Parent account must have the same account type\",\r\n            });\r\n          }\r\n\r\n          // Check if the new parent is a descendant (prevent circular reference)\r\n          const isDescendant = await checkIsDescendant(\r\n            ctx.db,\r\n            id,\r\n            input.parentId\r\n          );\r\n          if (isDescendant) {\r\n            throw new TRPCError({\r\n              code: \"BAD_REQUEST\",\r\n              message: \"Cannot set a descendant as parent (circular reference)\",\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // If changing account type, validate no children exist\r\n      if (input.accountType && input.accountType !== existing.accountType) {\r\n        if (existing.children.length > 0) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message:\r\n              \"Cannot change account type when child accounts exist\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update the account\r\n      const updated = await ctx.db.chartOfAccount.update({\r\n        where: { id },\r\n        data: {\r\n          ...updateData,\r\n          updatedById: ctx.session.user.id,\r\n        },\r\n        include: {\r\n          parent: true,\r\n          children: {\r\n            select: {\r\n              id: true,\r\n              code: true,\r\n              name: true,\r\n            },\r\n          },\r\n          createdBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          updatedBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"ChartOfAccount\",\r\n          entityId: id,\r\n          chartOfAccountId: id,\r\n          changes: {\r\n            before: existing,\r\n            after: updated,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Delete Chart of Account (Admin only)\r\n  // Soft delete (isActive=false) or hard delete if no dependencies\r\n  delete: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"DELETE\",\r\n        path: \"/chart-of-accounts/{id}\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Delete chart of account (Admin only)\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        force: z.boolean().optional().default(false),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Check if account exists\r\n      const account = await ctx.db.chartOfAccount.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          children: true,\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!account) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Chart of Account not found\",\r\n        });\r\n      }\r\n\r\n      // Check if account has children\r\n      if (account.children.length > 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message:\r\n            \"Cannot delete account with child accounts. Please delete or reassign child accounts first.\",\r\n        });\r\n      }\r\n\r\n      // Check if account has claims\r\n      if (account._count.claims > 0) {\r\n        if (input.force) {\r\n          // Soft delete: set isActive to false\r\n          const updated = await ctx.db.chartOfAccount.update({\r\n            where: { id: input.id },\r\n            data: {\r\n              isActive: false,\r\n              updatedById: ctx.session.user.id,\r\n            },\r\n          });\r\n\r\n          // Create audit log\r\n          await ctx.db.auditLog.create({\r\n            data: {\r\n              userId: ctx.session.user.id,\r\n              action: AuditAction.DELETE,\r\n              entityType: \"ChartOfAccount\",\r\n              entityId: input.id,\r\n              chartOfAccountId: input.id,\r\n              metadata: {\r\n                deleteType: \"soft\",\r\n                reason: \"Has associated claims\",\r\n                claimCount: account._count.claims,\r\n              },\r\n            },\r\n          });\r\n\r\n          return {\r\n            success: true,\r\n            deleteType: \"soft\",\r\n            account: updated,\r\n            message: `Account deactivated. ${account._count.claims} claim(s) are still associated with this account.`,\r\n          };\r\n        } else {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: `Cannot delete account with ${account._count.claims} associated claim(s). Use force=true to deactivate instead.`,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Hard delete: no dependencies\r\n      await ctx.db.chartOfAccount.delete({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.DELETE,\r\n          entityType: \"ChartOfAccount\",\r\n          entityId: input.id,\r\n          metadata: {\r\n            deleteType: \"hard\",\r\n            deletedAccount: account,\r\n          },\r\n        },\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        deleteType: \"hard\",\r\n        message: \"Account permanently deleted\",\r\n      };\r\n    }),\r\n\r\n  // Toggle active status (Admin only)\r\n  toggleActive: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: \"POST\",\r\n        path: \"/chart-of-accounts/{id}/toggle-active\",\r\n        protect: true,\r\n        tags: [\"Chart of Accounts\"],\r\n        summary: \"Toggle chart of account active status (Admin only)\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const account = await ctx.db.chartOfAccount.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!account) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Chart of Account not found\",\r\n        });\r\n      }\r\n\r\n      const newActiveStatus = !account.isActive;\r\n\r\n      // If activating, check parent is also active\r\n      if (newActiveStatus && account.parentId) {\r\n        const parent = await ctx.db.chartOfAccount.findUnique({\r\n          where: { id: account.parentId },\r\n        });\r\n\r\n        if (parent && !parent.isActive) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Cannot activate account when parent account is inactive\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // If deactivating, deactivate all children too\r\n      if (!newActiveStatus) {\r\n        const childrenCount = await ctx.db.chartOfAccount.count({\r\n          where: { parentId: input.id, isActive: true },\r\n        });\r\n\r\n        if (childrenCount > 0) {\r\n          // Deactivate all active children\r\n          await ctx.db.chartOfAccount.updateMany({\r\n            where: { parentId: input.id, isActive: true },\r\n            data: {\r\n              isActive: false,\r\n              updatedById: ctx.session.user.id,\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      const updated = await ctx.db.chartOfAccount.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          isActive: newActiveStatus,\r\n          updatedById: ctx.session.user.id,\r\n        },\r\n        include: {\r\n          parent: true,\r\n          children: true,\r\n          updatedBy: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"ChartOfAccount\",\r\n          entityId: input.id,\r\n          chartOfAccountId: input.id,\r\n          metadata: {\r\n            action: \"toggle_active\",\r\n            previousStatus: account.isActive,\r\n            newStatus: newActiveStatus,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n});\r\n\r\n// Helper function to check if an account is a descendant of another\r\nasync function checkIsDescendant(\r\n  db: any,\r\n  ancestorId: string,\r\n  descendantId: string\r\n): Promise<boolean> {\r\n  const descendant = await db.chartOfAccount.findUnique({\r\n    where: { id: descendantId },\r\n    select: { parentId: true },\r\n  });\r\n\r\n  if (!descendant || !descendant.parentId) {\r\n    return false;\r\n  }\r\n\r\n  if (descendant.parentId === ancestorId) {\r\n    return true;\r\n  }\r\n\r\n  return checkIsDescendant(db, ancestorId, descendant.parentId);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\claim.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1189,1192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1189,1192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .submitterId on an `any` value.","line":51,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":51,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":55,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":55,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .claimType on an `any` value.","line":59,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":59,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .travelRequestId on an `any` value.","line":63,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":63,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .submitterId on an `any` value.","line":67,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":67,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":71,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":71,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":73,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":73,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":73,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":76,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":76,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":76,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":76,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":83,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":83,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":893,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":893,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24990,24993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24990,24993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .submitter on an `any` value.","line":898,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":898,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":904,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":904,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":906,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":906,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":906,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":906,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":909,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":909,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":909,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":909,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":914,"column":30,"nodeType":"Property","messageId":"anyAssignment","endLine":914,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":926,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":926,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":932,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":935,"endColumn":12}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport {\r\n  ClaimType,\r\n  ClaimStatus,\r\n  EntertainmentType,\r\n  NonEntertainmentCategory,\r\n  ApprovalLevel,\r\n  TravelStatus,\r\n  AuditAction,\r\n} from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  financeProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const claimRouter = createTRPCRouter({\r\n  // Get all claims with filters\r\n  getAll: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/claims',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Get all claims',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        status: z.nativeEnum(ClaimStatus).optional(),\r\n        claimType: z.nativeEnum(ClaimType).optional(),\r\n        travelRequestId: z.string().optional(),\r\n        submitterId: z.string().optional(),\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      }).optional()\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n      };\r\n\r\n      // Non-finance users can only see their own claims\r\n      if (![\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(ctx.session.user.role)) {\r\n        where.submitterId = ctx.session.user.id;\r\n      }\r\n\r\n      if (input?.status) {\r\n        where.status = input.status;\r\n      }\r\n\r\n      if (input?.claimType) {\r\n        where.claimType = input.claimType;\r\n      }\r\n\r\n      if (input?.travelRequestId) {\r\n        where.travelRequestId = input.travelRequestId;\r\n      }\r\n\r\n      if (input?.submitterId) {\r\n        where.submitterId = input.submitterId;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const claims = await ctx.db.claim.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          submitter: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              department: {\r\n                select: {\r\n                  name: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          travelRequest: {\r\n            select: {\r\n              id: true,\r\n              requestNumber: true,\r\n              destination: true,\r\n              travelType: true,\r\n              status: true,\r\n            },\r\n          },\r\n          attachments: {\r\n            select: {\r\n              id: true,\r\n              filename: true,\r\n              mimeType: true,\r\n              fileSize: true,\r\n            },\r\n          },\r\n          approvals: {\r\n            include: {\r\n              approver: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  role: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (claims.length > limit) {\r\n        const nextItem = claims.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        claims,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get claim by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/claims/{id}',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Get claim by ID',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"get_claim\",\r\n        description: \"Get detailed information about a specific claim for review or resume\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          submitter: {\r\n            include: {\r\n              department: true,\r\n            },\r\n          },\r\n          travelRequest: {\r\n            include: {\r\n              requester: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          attachments: true,\r\n          approvals: {\r\n            include: {\r\n              approver: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                  role: true,\r\n                },\r\n              },\r\n            },\r\n            orderBy: {\r\n              createdAt: \"asc\",\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isSubmitter = claim.submitterId === ctx.session.user.id;\r\n      const isRequester = claim.travelRequest.requesterId === ctx.session.user.id;\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isSubmitter && !isRequester && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this claim\",\r\n        });\r\n      }\r\n\r\n      return claim;\r\n    }),\r\n\r\n  // Get claims by travel request\r\n  getByTravelRequest: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/claims/by-travel-request/{travelRequestId}',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Get claims by travel request',\r\n      }\r\n    })\r\n    .input(z.object({ travelRequestId: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      // Verify access to travel request\r\n      const travelRequest = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.travelRequestId },\r\n        include: {\r\n          participants: true,\r\n        },\r\n      });\r\n\r\n      if (!travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      const isRequester = travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"FINANCE\", \"ADMIN\", \"MANAGER\", \"DIRECTOR\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view claims for this travel request\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.claim.findMany({\r\n        where: {\r\n          travelRequestId: input.travelRequestId,\r\n          deletedAt: null,\r\n        },\r\n        include: {\r\n          submitter: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          attachments: {\r\n            select: {\r\n              id: true,\r\n              filename: true,\r\n              mimeType: true,\r\n              fileSize: true,\r\n            },\r\n          },\r\n          approvals: {\r\n            include: {\r\n              approver: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  role: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Create entertainment claim\r\n  createEntertainment: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/claims/entertainment',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Create entertainment claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"create_entertainment_claim_draft\",\r\n        description: \"Create a draft entertainment claim for a travel request\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        travelRequestId: z.string(),\r\n        entertainmentType: z.nativeEnum(EntertainmentType),\r\n        entertainmentDate: z.coerce.date(),\r\n        entertainmentLocation: z.string(),\r\n        entertainmentAddress: z.string().optional(),\r\n        guestName: z.string(),\r\n        guestCompany: z.string().optional(),\r\n        guestPosition: z.string().optional(),\r\n        isGovernmentOfficial: z.boolean().optional(),\r\n        amount: z.number().positive(),\r\n        description: z.string().min(10),\r\n        notes: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { travelRequestId, ...claimData } = input;\r\n\r\n      // Verify travel request exists and is approved\r\n      const travelRequest = await ctx.db.travelRequest.findUnique({\r\n        where: { id: travelRequestId },\r\n        include: {\r\n          participants: true,\r\n        },\r\n      });\r\n\r\n      if (!travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Check if user is requester or participant\r\n      const isRequester = travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n\r\n      if (!isRequester && !isParticipant) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"You are not authorized to create claims for this travel request\",\r\n        });\r\n      }\r\n\r\n      // Check if travel request is approved or locked\r\n      if (!([ TravelStatus.APPROVED, TravelStatus.LOCKED] as TravelStatus[]).includes(travelRequest.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Claims can only be created for approved travel requests\",\r\n        });\r\n      }\r\n\r\n      // Generate claim number\r\n      const year = new Date().getFullYear();\r\n      const count = await ctx.db.claim.count({\r\n        where: {\r\n          claimNumber: {\r\n            startsWith: `CLM-${year}`,\r\n          },\r\n        },\r\n      });\r\n      const claimNumber = `CLM-${year}-${String(count + 1).padStart(5, \"0\")}`;\r\n\r\n      // Create claim\r\n      const claim = await ctx.db.claim.create({\r\n        data: {\r\n          claimNumber,\r\n          travelRequestId,\r\n          submitterId: ctx.session.user.id,\r\n          claimType: ClaimType.ENTERTAINMENT,\r\n          ...claimData,\r\n        },\r\n        include: {\r\n          submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n          travelRequest: true,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"Claim\",\r\n          entityId: claim.id,\r\n          changes: {\r\n            after: claim,\r\n          },\r\n        },\r\n      });\r\n\r\n      return claim;\r\n    }),\r\n\r\n  // Create non-entertainment claim\r\n  createNonEntertainment: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/claims/non-entertainment',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Create non-entertainment claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"create_nonentertainment_claim_draft\",\r\n        description: \"Create a draft non-entertainment claim for a travel request\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        travelRequestId: z.string(),\r\n        expenseCategory: z.nativeEnum(NonEntertainmentCategory),\r\n        expenseDate: z.coerce.date(),\r\n        expenseDestination: z.string().optional(),\r\n        customerName: z.string().optional(),\r\n        amount: z.number().positive(),\r\n        description: z.string().min(10),\r\n        notes: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { travelRequestId, ...claimData } = input;\r\n\r\n      // Verify travel request\r\n      const travelRequest = await ctx.db.travelRequest.findUnique({\r\n        where: { id: travelRequestId },\r\n        include: {\r\n          participants: true,\r\n        },\r\n      });\r\n\r\n      if (!travelRequest) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Check authorization\r\n      const isRequester = travelRequest.requesterId === ctx.session.user.id;\r\n      const isParticipant = travelRequest.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n\r\n      if (!isRequester && !isParticipant) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"You are not authorized to create claims for this travel request\",\r\n        });\r\n      }\r\n\r\n      // Check travel request status\r\n      if (!([TravelStatus.APPROVED, TravelStatus.LOCKED] as TravelStatus[]).includes(travelRequest.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Claims can only be created for approved travel requests\",\r\n        });\r\n      }\r\n\r\n      // Generate claim number\r\n      const year = new Date().getFullYear();\r\n      const count = await ctx.db.claim.count({\r\n        where: {\r\n          claimNumber: {\r\n            startsWith: `CLM-${year}`,\r\n          },\r\n        },\r\n      });\r\n      const claimNumber = `CLM-${year}-${String(count + 1).padStart(5, \"0\")}`;\r\n\r\n      // Create claim\r\n      const claim = await ctx.db.claim.create({\r\n        data: {\r\n          claimNumber,\r\n          travelRequestId,\r\n          submitterId: ctx.session.user.id,\r\n          claimType: ClaimType.NON_ENTERTAINMENT,\r\n          ...claimData,\r\n        },\r\n        include: {\r\n          submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n          travelRequest: true,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"Claim\",\r\n          entityId: claim.id,\r\n          changes: {\r\n            after: claim,\r\n          },\r\n        },\r\n      });\r\n\r\n      return claim;\r\n    }),\r\n\r\n  // Update claim (only in DRAFT or REVISION status)\r\n  update: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PUT',\r\n        path: '/claims/{id}',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Update claim',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"update_claim_draft\",\r\n        description: \"Update a claim draft (only works for DRAFT or REVISION status)\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        entertainmentType: z.nativeEnum(EntertainmentType).optional(),\r\n        entertainmentDate: z.coerce.date().optional(),\r\n        entertainmentLocation: z.string().optional(),\r\n        entertainmentAddress: z.string().optional(),\r\n        guestName: z.string().optional(),\r\n        guestCompany: z.string().optional(),\r\n        guestPosition: z.string().optional(),\r\n        isGovernmentOfficial: z.boolean().optional(),\r\n        expenseCategory: z.nativeEnum(NonEntertainmentCategory).optional(),\r\n        expenseDate: z.coerce.date().optional(),\r\n        expenseDestination: z.string().optional(),\r\n        customerName: z.string().optional(),\r\n        amount: z.number().positive().optional(),\r\n        description: z.string().min(10).optional(),\r\n        notes: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      const existing = await ctx.db.claim.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!existing) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Only submitter can update\r\n      if (existing.submitterId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only the submitter can update this claim\",\r\n        });\r\n      }\r\n\r\n      // Can only update DRAFT or REVISION claims\r\n      if (!([ClaimStatus.DRAFT, ClaimStatus.REVISION] as ClaimStatus[]).includes(existing.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only update claims in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.claim.update({\r\n        where: { id },\r\n        data: updateData,\r\n        include: {\r\n          submitter: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n          travelRequest: true,\r\n          attachments: true,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"Claim\",\r\n          entityId: id,\r\n          changes: {\r\n            before: existing,\r\n            after: updated,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Submit claim for approval\r\n  submit: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/claims/{id}/submit',\r\n        protect: true,\r\n        tags: ['Claims'],\r\n        summary: 'Submit claim for approval',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"submit_claim\",\r\n        description: \"Submit a draft claim for approval\",\r\n      },\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          submitter: {\r\n            include: {\r\n              supervisor: true,\r\n              department: true,\r\n            },\r\n          },\r\n          travelRequest: true,\r\n          attachments: true,\r\n        },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      if (claim.submitterId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only the submitter can submit this claim\",\r\n        });\r\n      }\r\n\r\n      if (!([ClaimStatus.DRAFT, ClaimStatus.REVISION] as ClaimStatus[]).includes(claim.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only submit claims in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      // Validate attachments exist\r\n      if (claim.attachments.length === 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"At least one attachment is required to submit a claim\",\r\n        });\r\n      }\r\n\r\n      // Create approval workflow\r\n      const approvals = [];\r\n\r\n      // L1: Supervisor\r\n      if (claim.submitter.supervisorId) {\r\n        approvals.push({\r\n          level: ApprovalLevel.L1_SUPERVISOR,\r\n          approverId: claim.submitter.supervisorId,\r\n        });\r\n      }\r\n\r\n      // L2: Finance for high amounts (example: > 5000000)\r\n      if (Number(claim.amount) > 5000000) {\r\n        // Find finance user\r\n        const financeUser = await ctx.db.user.findFirst({\r\n          where: {\r\n            role: \"FINANCE\",\r\n            deletedAt: null,\r\n          },\r\n        });\r\n\r\n        if (financeUser) {\r\n          approvals.push({\r\n            level: ApprovalLevel.L2_MANAGER,\r\n            approverId: financeUser.id,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update claim and create approvals\r\n      const updated = await ctx.db.claim.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: ClaimStatus.SUBMITTED,\r\n          approvals: {\r\n            create: approvals,\r\n          },\r\n        },\r\n        include: {\r\n          approvals: {\r\n            include: {\r\n              approver: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, image: true } },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.SUBMIT,\r\n          entityType: \"Claim\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      // TODO: Send notifications to approvers\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Mark claim as paid (Finance only)\r\n  markAsPaid: financeProcedure\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        paymentReference: z.string(),\r\n        paidBy: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      if (claim.status !== ClaimStatus.APPROVED) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only mark approved claims as paid\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.claim.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: ClaimStatus.PAID,\r\n          isPaid: true,\r\n          paidAt: new Date(),\r\n          paidBy: input.paidBy ?? ctx.session.user.name,\r\n          paymentReference: input.paymentReference,\r\n        },\r\n      });\r\n\r\n      // Update travel request total reimbursed\r\n      const totalPaid = await ctx.db.claim.aggregate({\r\n        where: {\r\n          travelRequestId: claim.travelRequestId,\r\n          status: ClaimStatus.PAID,\r\n        },\r\n        _sum: {\r\n          amount: true,\r\n        },\r\n      });\r\n\r\n      await ctx.db.travelRequest.update({\r\n        where: { id: claim.travelRequestId },\r\n        data: {\r\n          totalReimbursed: totalPaid._sum.amount ?? 0,\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"Claim\",\r\n          entityId: input.id,\r\n          metadata: {\r\n            action: \"marked_as_paid\",\r\n            paymentReference: input.paymentReference,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Delete claim (soft delete)\r\n  delete: protectedProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const claim = await ctx.db.claim.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!claim) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Claim not found\",\r\n        });\r\n      }\r\n\r\n      // Only submitter or admin can delete\r\n      const canDelete =\r\n        claim.submitterId === ctx.session.user.id ||\r\n        ctx.session.user.role === \"ADMIN\";\r\n\r\n      if (!canDelete) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to delete this claim\",\r\n        });\r\n      }\r\n\r\n      // Can only delete DRAFT claims\r\n      if (claim.status !== ClaimStatus.DRAFT) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only delete claims in DRAFT status\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.claim.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.DELETE,\r\n          entityType: \"Claim\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Get claim statistics\r\n  getStatistics: financeProcedure\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        departmentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n      };\r\n\r\n      if (input?.departmentId) {\r\n        where.submitter = {\r\n          departmentId: input.departmentId,\r\n        };\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const [total, byStatus, byType, totalAmount, paidAmount] = await Promise.all([\r\n        ctx.db.claim.count({ where }),\r\n        ctx.db.claim.groupBy({\r\n          by: [\"status\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.claim.groupBy({\r\n          by: [\"claimType\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.claim.aggregate({\r\n          where,\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        ctx.db.claim.aggregate({\r\n          where: {\r\n            ...where,\r\n            status: ClaimStatus.PAID,\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n      ]);\r\n\r\n      return {\r\n        total,\r\n        byStatus: byStatus.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        byType: byType.map((item) => ({\r\n          type: item.claimType,\r\n          count: item._count,\r\n        })),\r\n        totalAmount: totalAmount._sum.amount ?? 0,\r\n        paidAmount: paidAmount._sum.amount ?? 0,\r\n      };\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\dashboard.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4211,4214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4211,4214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .requester on an `any` value.","line":184,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":184,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":226,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":226,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":268,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":273,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9776,9779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9776,9779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":378,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":378,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":380,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":380,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .createdAt on an `any` value.","line":383,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":383,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":411,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":415,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":422,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":426,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":605,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":605,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16125,16128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16125,16128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .requester on an `any` value.","line":614,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":614,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":634,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":634,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":693,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":693,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18494,18497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18494,18497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .submitter on an `any` value.","line":702,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":702,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":726,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":726,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":737,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":737,"endColumn":16}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport {\r\n  TravelStatus,\r\n  ClaimStatus,\r\n  ApprovalStatus,\r\n} from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  managerProcedure,\r\n  financeProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const dashboardRouter = createTRPCRouter({\r\n  // Get user dashboard statistics\r\n  getMyDashboard: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/dashboard/my',\r\n        protect: true,\r\n        tags: ['Dashboard'],\r\n        summary: 'Get my dashboard statistics',\r\n      }\r\n    })\r\n    .input(z.object({}))\r\n    .output(z.any())\r\n    .query(async ({ ctx }) => {\r\n    const userId = ctx.session.user.id;\r\n\r\n    // Get counts in parallel\r\n    const [\r\n      myTravelRequests,\r\n      myClaims,\r\n      pendingApprovals,\r\n      unreadNotifications,\r\n      myTeamTravelRequests,\r\n    ] = await Promise.all([\r\n      // My travel requests count by status\r\n      ctx.db.travelRequest.groupBy({\r\n        by: [\"status\"],\r\n        where: {\r\n          requesterId: userId,\r\n          deletedAt: null,\r\n        },\r\n        _count: true,\r\n      }),\r\n      // My claims count by status\r\n      ctx.db.claim.groupBy({\r\n        by: [\"status\"],\r\n        where: {\r\n          submitterId: userId,\r\n          deletedAt: null,\r\n        },\r\n        _count: true,\r\n      }),\r\n      // Pending approvals for me\r\n      ctx.db.approval.count({\r\n        where: {\r\n          approverId: userId,\r\n          status: ApprovalStatus.PENDING,\r\n        },\r\n      }),\r\n      // Unread notifications\r\n      ctx.db.notification.count({\r\n        where: {\r\n          userId,\r\n          readAt: null,\r\n        },\r\n      }),\r\n      // Team travel requests (if supervisor)\r\n      ctx.db.travelRequest.count({\r\n        where: {\r\n          requester: {\r\n            supervisorId: userId,\r\n          },\r\n          status: {\r\n            in: [TravelStatus.DRAFT, TravelStatus.SUBMITTED],\r\n          },\r\n          deletedAt: null,\r\n        },\r\n      }),\r\n    ]);\r\n\r\n    // Get recent travel requests\r\n    const recentTravelRequests = await ctx.db.travelRequest.findMany({\r\n      take: 5,\r\n      where: {\r\n        requesterId: userId,\r\n        deletedAt: null,\r\n      },\r\n      include: {\r\n        approvals: {\r\n          include: {\r\n            approver: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                role: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n    });\r\n\r\n    // Get recent claims\r\n    const recentClaims = await ctx.db.claim.findMany({\r\n      take: 5,\r\n      where: {\r\n        submitterId: userId,\r\n        deletedAt: null,\r\n      },\r\n      include: {\r\n        travelRequest: {\r\n          select: {\r\n            requestNumber: true,\r\n            destination: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n    });\r\n\r\n    return {\r\n      travelRequests: {\r\n        total: myTravelRequests.reduce((sum, item) => sum + item._count, 0),\r\n        byStatus: myTravelRequests.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        recent: recentTravelRequests,\r\n      },\r\n      claims: {\r\n        total: myClaims.reduce((sum, item) => sum + item._count, 0),\r\n        byStatus: myClaims.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        recent: recentClaims,\r\n      },\r\n      approvals: {\r\n        pending: pendingApprovals,\r\n      },\r\n      notifications: {\r\n        unread: unreadNotifications,\r\n      },\r\n      team: {\r\n        pendingRequests: myTeamTravelRequests,\r\n      },\r\n    };\r\n  }),\r\n\r\n  // Get manager dashboard\r\n  getManagerDashboard: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/dashboard/manager',\r\n        protect: true,\r\n        tags: ['Dashboard'],\r\n        summary: 'Get manager dashboard statistics',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        departmentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n      };\r\n\r\n      // Filter by department if provided\r\n      if (input?.departmentId) {\r\n        where.requester = {\r\n          departmentId: input.departmentId,\r\n        };\r\n      }\r\n\r\n      // Get various statistics in parallel\r\n      const [\r\n        travelRequestsByStatus,\r\n        claimsByStatus,\r\n        pendingApprovals,\r\n        recentActivity,\r\n        topSpenders,\r\n        monthlyTrend,\r\n      ] = await Promise.all([\r\n        // Travel requests by status\r\n        ctx.db.travelRequest.groupBy({\r\n          by: [\"status\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        // Claims by status\r\n        ctx.db.claim.groupBy({\r\n          by: [\"status\"],\r\n          where: input?.departmentId\r\n            ? {\r\n                submitter: {\r\n                  departmentId: input.departmentId,\r\n                },\r\n                deletedAt: null,\r\n              }\r\n            : { deletedAt: null },\r\n          _count: true,\r\n        }),\r\n        // Pending approvals count\r\n        ctx.db.approval.count({\r\n          where: {\r\n            status: ApprovalStatus.PENDING,\r\n          },\r\n        }),\r\n        // Recent travel requests\r\n        ctx.db.travelRequest.findMany({\r\n          take: 10,\r\n          where,\r\n          include: {\r\n            requester: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                department: {\r\n                  select: {\r\n                    name: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n          orderBy: {\r\n            createdAt: \"desc\",\r\n          },\r\n        }),\r\n        // Top spenders (users with highest total claims)\r\n        ctx.db.claim.groupBy({\r\n          by: [\"submitterId\"],\r\n          where: {\r\n            status: ClaimStatus.PAID,\r\n            ...(input?.departmentId && {\r\n              submitter: {\r\n                departmentId: input.departmentId,\r\n              },\r\n            }),\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n          orderBy: {\r\n            _sum: {\r\n              amount: \"desc\",\r\n            },\r\n          },\r\n          take: 10,\r\n        }),\r\n        // Monthly trend (last 6 months)\r\n        ctx.db.travelRequest.findMany({\r\n          where: {\r\n            ...where,\r\n            createdAt: {\r\n              gte: new Date(new Date().setMonth(new Date().getMonth() - 6)),\r\n            },\r\n          },\r\n          select: {\r\n            createdAt: true,\r\n            status: true,\r\n          },\r\n        }),\r\n      ]);\r\n\r\n      // Get user details for top spenders\r\n      const spenderIds = topSpenders.map((s) => s.submitterId);\r\n      const spenderUsers = await ctx.db.user.findMany({\r\n        where: {\r\n          id: { in: spenderIds },\r\n        },\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n          employeeId: true,\r\n          department: {\r\n            select: {\r\n              name: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      const topSpendersWithDetails = topSpenders.map((spender) => {\r\n        const user = spenderUsers.find((u) => u.id === spender.submitterId);\r\n        return {\r\n          userId: spender.submitterId,\r\n          userName: user?.name ?? \"Unknown\",\r\n          userEmail: user?.email,\r\n          employeeId: user?.employeeId,\r\n          department: user?.department?.name,\r\n          totalAmount: spender._sum.amount ?? 0,\r\n        };\r\n      });\r\n\r\n      // Calculate monthly trend\r\n      const monthlyData = new Map<string, { submitted: number; approved: number }>();\r\n      monthlyTrend.forEach((request) => {\r\n        const month = request.createdAt.toISOString().slice(0, 7); // YYYY-MM\r\n        if (!monthlyData.has(month)) {\r\n          monthlyData.set(month, { submitted: 0, approved: 0 });\r\n        }\r\n        const data = monthlyData.get(month)!;\r\n        data.submitted += 1;\r\n        if (request.status === TravelStatus.APPROVED) {\r\n          data.approved += 1;\r\n        }\r\n      });\r\n\r\n      const monthlyTrendArray = Array.from(monthlyData.entries())\r\n        .map(([month, data]) => ({\r\n          month,\r\n          ...data,\r\n        }))\r\n        .sort((a, b) => a.month.localeCompare(b.month));\r\n\r\n      return {\r\n        travelRequests: {\r\n          total: travelRequestsByStatus.reduce((sum, item) => sum + item._count, 0),\r\n          byStatus: travelRequestsByStatus.map((item) => ({\r\n            status: item.status,\r\n            count: item._count,\r\n          })),\r\n        },\r\n        claims: {\r\n          total: claimsByStatus.reduce((sum, item) => sum + item._count, 0),\r\n          byStatus: claimsByStatus.map((item) => ({\r\n            status: item.status,\r\n            count: item._count,\r\n          })),\r\n        },\r\n        approvals: {\r\n          pending: pendingApprovals,\r\n        },\r\n        recentActivity,\r\n        topSpenders: topSpendersWithDetails,\r\n        monthlyTrend: monthlyTrendArray,\r\n      };\r\n    }),\r\n\r\n  // Get finance dashboard\r\n  getFinanceDashboard: financeProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/dashboard/finance',\r\n        protect: true,\r\n        tags: ['Dashboard'],\r\n        summary: 'Get finance dashboard statistics',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const dateFilter: any = {};\r\n      if (input?.startDate || input?.endDate) {\r\n        dateFilter.createdAt = {};\r\n        if (input.startDate) {\r\n          dateFilter.createdAt.gte = input.startDate;\r\n        }\r\n        if (input.endDate) {\r\n          dateFilter.createdAt.lte = input.endDate;\r\n        }\r\n      }\r\n\r\n      // Get financial statistics\r\n      const [\r\n        claimsByStatus,\r\n        totalApprovedAmount,\r\n        totalPaidAmount,\r\n        claimsByType,\r\n        claimsByDepartment,\r\n        pendingPayments,\r\n        recentPaidClaims,\r\n      ] = await Promise.all([\r\n        // Claims by status\r\n        ctx.db.claim.groupBy({\r\n          by: [\"status\"],\r\n          where: {\r\n            deletedAt: null,\r\n            ...dateFilter,\r\n          },\r\n          _count: true,\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Total approved amount\r\n        ctx.db.claim.aggregate({\r\n          where: {\r\n            status: ClaimStatus.APPROVED,\r\n            deletedAt: null,\r\n            ...dateFilter,\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Total paid amount\r\n        ctx.db.claim.aggregate({\r\n          where: {\r\n            status: ClaimStatus.PAID,\r\n            deletedAt: null,\r\n            ...dateFilter,\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Claims by type\r\n        ctx.db.claim.groupBy({\r\n          by: [\"claimType\"],\r\n          where: {\r\n            deletedAt: null,\r\n            ...dateFilter,\r\n          },\r\n          _count: true,\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Claims by department\r\n        ctx.db.claim.groupBy({\r\n          by: [\"submitterId\"],\r\n          where: {\r\n            status: ClaimStatus.PAID,\r\n            deletedAt: null,\r\n            ...dateFilter,\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Pending payments\r\n        ctx.db.claim.findMany({\r\n          where: {\r\n            status: ClaimStatus.APPROVED,\r\n            deletedAt: null,\r\n          },\r\n          include: {\r\n            submitter: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                employeeId: true,\r\n                department: {\r\n                  select: {\r\n                    name: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            travelRequest: {\r\n              select: {\r\n                requestNumber: true,\r\n                destination: true,\r\n              },\r\n            },\r\n          },\r\n          orderBy: {\r\n            createdAt: \"asc\",\r\n          },\r\n        }),\r\n        // Recent paid claims\r\n        ctx.db.claim.findMany({\r\n          take: 10,\r\n          where: {\r\n            status: ClaimStatus.PAID,\r\n            deletedAt: null,\r\n          },\r\n          include: {\r\n            submitter: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                employeeId: true,\r\n              },\r\n            },\r\n            travelRequest: {\r\n              select: {\r\n                requestNumber: true,\r\n                destination: true,\r\n              },\r\n            },\r\n          },\r\n          orderBy: {\r\n            paidAt: \"desc\",\r\n          },\r\n        }),\r\n      ]);\r\n\r\n      // Calculate department spending\r\n      const submitterIds = claimsByDepartment.map((c) => c.submitterId);\r\n      const submitters = await ctx.db.user.findMany({\r\n        where: {\r\n          id: { in: submitterIds },\r\n        },\r\n        select: {\r\n          id: true,\r\n          department: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      const departmentSpending = new Map<string, { name: string; amount: number }>();\r\n      claimsByDepartment.forEach((claim) => {\r\n        const user = submitters.find((u) => u.id === claim.submitterId);\r\n        if (user?.department) {\r\n          const existing = departmentSpending.get(user.department.id);\r\n          const amount = claim._sum.amount ?? 0;\r\n          if (existing) {\r\n            existing.amount += Number(amount);\r\n          } else {\r\n            departmentSpending.set(user.department.id, {\r\n              name: user.department.name,\r\n              amount: Number(amount),\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      const departmentSpendingArray = Array.from(departmentSpending.entries())\r\n        .map(([id, data]) => ({\r\n          departmentId: id,\r\n          departmentName: data.name,\r\n          totalAmount: data.amount,\r\n        }))\r\n        .sort((a, b) => b.totalAmount - a.totalAmount);\r\n\r\n      return {\r\n        overview: {\r\n          totalApproved: totalApprovedAmount._sum.amount ?? 0,\r\n          totalPaid: totalPaidAmount._sum.amount ?? 0,\r\n          pendingPayment: Number(totalApprovedAmount._sum.amount ?? 0) - Number(totalPaidAmount._sum.amount ?? 0),\r\n        },\r\n        claims: {\r\n          byStatus: claimsByStatus.map((item) => ({\r\n            status: item.status,\r\n            count: item._count,\r\n            amount: item._sum.amount ?? 0,\r\n          })),\r\n          byType: claimsByType.map((item) => ({\r\n            type: item.claimType,\r\n            count: item._count,\r\n            amount: item._sum.amount ?? 0,\r\n          })),\r\n        },\r\n        departmentSpending: departmentSpendingArray,\r\n        pendingPayments: {\r\n          count: pendingPayments.length,\r\n          total: pendingPayments.reduce((sum, claim) => sum + Number(claim.amount), 0),\r\n          claims: pendingPayments,\r\n        },\r\n        recentPayments: recentPaidClaims,\r\n      };\r\n    }),\r\n\r\n  // Get analytics - Travel trends\r\n  getTravelTrends: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/dashboard/travel-trends',\r\n        protect: true,\r\n        tags: ['Dashboard'],\r\n        summary: 'Get travel trends analytics',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date(),\r\n        endDate: z.coerce.date(),\r\n        departmentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n        createdAt: {\r\n          gte: input.startDate,\r\n          lte: input.endDate,\r\n        },\r\n      };\r\n\r\n      if (input.departmentId) {\r\n        where.requester = {\r\n          departmentId: input.departmentId,\r\n        };\r\n      }\r\n\r\n      const [byType, byStatus, byMonth] = await Promise.all([\r\n        // By travel type\r\n        ctx.db.travelRequest.groupBy({\r\n          by: [\"travelType\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        // By status\r\n        ctx.db.travelRequest.groupBy({\r\n          by: [\"status\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        // By month\r\n        ctx.db.travelRequest.findMany({\r\n          where,\r\n          select: {\r\n            createdAt: true,\r\n            travelType: true,\r\n          },\r\n        }),\r\n      ]);\r\n\r\n      // Calculate monthly breakdown\r\n      const monthlyData = new Map<string, Map<string, number>>();\r\n      byMonth.forEach((request) => {\r\n        const month = request.createdAt.toISOString().slice(0, 7);\r\n        if (!monthlyData.has(month)) {\r\n          monthlyData.set(month, new Map());\r\n        }\r\n        const typeMap = monthlyData.get(month)!;\r\n        typeMap.set(request.travelType, (typeMap.get(request.travelType) ?? 0) + 1);\r\n      });\r\n\r\n      const monthlyTrend = Array.from(monthlyData.entries())\r\n        .map(([month, types]) => ({\r\n          month,\r\n          ...Object.fromEntries(types),\r\n        }))\r\n        .sort((a, b) => a.month.localeCompare(b.month));\r\n\r\n      return {\r\n        byType: byType.map((item) => ({\r\n          type: item.travelType,\r\n          count: item._count,\r\n        })),\r\n        byStatus: byStatus.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        monthlyTrend,\r\n      };\r\n    }),\r\n\r\n  // Get analytics - Expense analysis\r\n  getExpenseAnalysis: financeProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/dashboard/expense-analysis',\r\n        protect: true,\r\n        tags: ['Dashboard'],\r\n        summary: 'Get expense analysis',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date(),\r\n        endDate: z.coerce.date(),\r\n        departmentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n        createdAt: {\r\n          gte: input.startDate,\r\n          lte: input.endDate,\r\n        },\r\n      };\r\n\r\n      if (input.departmentId) {\r\n        where.submitter = {\r\n          departmentId: input.departmentId,\r\n        };\r\n      }\r\n\r\n      const [byCategory, averages, totalByMonth] = await Promise.all([\r\n        // Entertainment types\r\n        ctx.db.claim.groupBy({\r\n          by: [\"entertainmentType\"],\r\n          where: {\r\n            ...where,\r\n            claimType: \"ENTERTAINMENT\",\r\n            entertainmentType: { not: null },\r\n          },\r\n          _count: true,\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n          _avg: {\r\n            amount: true,\r\n          },\r\n        }),\r\n        // Overall averages\r\n        ctx.db.claim.aggregate({\r\n          where,\r\n          _avg: {\r\n            amount: true,\r\n          },\r\n          _sum: {\r\n            amount: true,\r\n          },\r\n          _count: true,\r\n        }),\r\n        // Total by month\r\n        ctx.db.claim.findMany({\r\n          where,\r\n          select: {\r\n            createdAt: true,\r\n            amount: true,\r\n            claimType: true,\r\n          },\r\n        }),\r\n      ]);\r\n\r\n      // Calculate monthly totals\r\n      const monthlyTotals = new Map<string, { entertainment: number; nonEntertainment: number }>();\r\n      totalByMonth.forEach((claim) => {\r\n        const month = claim.createdAt.toISOString().slice(0, 7);\r\n        if (!monthlyTotals.has(month)) {\r\n          monthlyTotals.set(month, { entertainment: 0, nonEntertainment: 0 });\r\n        }\r\n        const data = monthlyTotals.get(month)!;\r\n        if (claim.claimType === \"ENTERTAINMENT\") {\r\n          data.entertainment += Number(claim.amount);\r\n        } else {\r\n          data.nonEntertainment += Number(claim.amount);\r\n        }\r\n      });\r\n\r\n      const monthlyTrend = Array.from(monthlyTotals.entries())\r\n        .map(([month, data]) => ({\r\n          month,\r\n          ...data,\r\n          total: data.entertainment + data.nonEntertainment,\r\n        }))\r\n        .sort((a, b) => a.month.localeCompare(b.month));\r\n\r\n      return {\r\n        overview: {\r\n          totalAmount: averages._sum.amount ?? 0,\r\n          averageAmount: averages._avg.amount ?? 0,\r\n          totalClaims: averages._count,\r\n        },\r\n        byCategory: byCategory.map((item) => ({\r\n          category: item.entertainmentType!,\r\n          count: item._count,\r\n          total: item._sum.amount ?? 0,\r\n          average: item._avg.amount ?? 0,\r\n        })),\r\n        monthlyTrend,\r\n      };\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\department.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":423,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":423,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10700,10703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10700,10703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":427,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":430,"endColumn":5},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":427,"column":28,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":427,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .department on an `any` value.","line":427,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":427,"endColumn":41},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":432,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":432,"endColumn":42,"fix":{"range":[10913,10948],"text":"!descendant?.parentId"}},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":432,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":432,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":436,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":436,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .parentId on an `any` value.","line":440,"column":55,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":440,"endColumn":63}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  adminProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const departmentRouter = createTRPCRouter({\r\n  // Get all departments with optional filters\r\n  getAll: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/departments',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Get all departments',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        includeDeleted: z.boolean().optional(),\r\n        parentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      return ctx.db.department.findMany({\r\n        where: {\r\n          deletedAt: input.includeDeleted ? undefined : null,\r\n          parentId: input.parentId,\r\n        },\r\n        include: {\r\n          parent: true,\r\n          children: true,\r\n          users: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          name: \"asc\",\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Get department by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/departments/{id}',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Get department by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const department = await ctx.db.department.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          parent: true,\r\n          children: true,\r\n          users: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n              employeeId: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!department) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Department not found\",\r\n        });\r\n      }\r\n\r\n      return department;\r\n    }),\r\n\r\n  // Get department by code\r\n  getByCode: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/departments/by-code/{code}',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Get department by code',\r\n      }\r\n    })\r\n    .input(z.object({ code: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const department = await ctx.db.department.findUnique({\r\n        where: { code: input.code },\r\n        include: {\r\n          parent: true,\r\n          children: true,\r\n          users: true,\r\n        },\r\n      });\r\n\r\n      if (!department) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Department not found\",\r\n        });\r\n      }\r\n\r\n      return department;\r\n    }),\r\n\r\n  // Get department hierarchy tree\r\n  getHierarchy: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/departments/hierarchy',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Get department hierarchy tree',\r\n      }\r\n    })\r\n    .input(z.object({}))\r\n    .output(z.any())\r\n    .query(async ({ ctx }) => {\r\n    // Get all root departments (no parent)\r\n    const rootDepartments = await ctx.db.department.findMany({\r\n      where: {\r\n        parentId: null,\r\n        deletedAt: null,\r\n      },\r\n      include: {\r\n        children: {\r\n          include: {\r\n            children: {\r\n              include: {\r\n                children: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        users: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            role: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        name: \"asc\",\r\n      },\r\n    });\r\n\r\n    return rootDepartments;\r\n  }),\r\n\r\n  // Create department\r\n  create: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/departments',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Create department',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        name: z.string().min(1).max(100),\r\n        code: z.string().min(1).max(20),\r\n        description: z.string().optional(),\r\n        parentId: z.string().optional(),\r\n        managerId: z.string().optional(),\r\n        directorId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Check if code already exists\r\n      const existing = await ctx.db.department.findUnique({\r\n        where: { code: input.code },\r\n      });\r\n\r\n      if (existing) {\r\n        throw new TRPCError({\r\n          code: \"CONFLICT\",\r\n          message: \"Department code already exists\",\r\n        });\r\n      }\r\n\r\n      // Validate parent exists if provided\r\n      if (input.parentId) {\r\n        const parent = await ctx.db.department.findUnique({\r\n          where: { id: input.parentId },\r\n        });\r\n        if (!parent) {\r\n          throw new TRPCError({\r\n            code: \"NOT_FOUND\",\r\n            message: \"Parent department not found\",\r\n          });\r\n        }\r\n      }\r\n\r\n      return ctx.db.department.create({\r\n        data: {\r\n          name: input.name,\r\n          code: input.code,\r\n          description: input.description,\r\n          parentId: input.parentId,\r\n          managerId: input.managerId,\r\n          directorId: input.directorId,\r\n        },\r\n        include: {\r\n          parent: true,\r\n          users: true,\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Update department\r\n  update: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PUT',\r\n        path: '/departments/{id}',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Update department',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        name: z.string().min(1).max(100).optional(),\r\n        code: z.string().min(1).max(20).optional(),\r\n        description: z.string().optional(),\r\n        parentId: z.string().optional().nullable(),\r\n        managerId: z.string().optional().nullable(),\r\n        directorId: z.string().optional().nullable(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      // Check if department exists\r\n      const department = await ctx.db.department.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!department) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Department not found\",\r\n        });\r\n      }\r\n\r\n      // If updating code, check for conflicts\r\n      if (input.code && input.code !== department.code) {\r\n        const existing = await ctx.db.department.findUnique({\r\n          where: { code: input.code },\r\n        });\r\n        if (existing) {\r\n          throw new TRPCError({\r\n            code: \"CONFLICT\",\r\n            message: \"Department code already exists\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Prevent circular references in parent hierarchy\r\n      if (input.parentId) {\r\n        if (input.parentId === id) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Department cannot be its own parent\",\r\n          });\r\n        }\r\n\r\n        // Check if the new parent is a descendant\r\n        const isDescendant = await checkIsDescendant(\r\n          ctx.db,\r\n          id,\r\n          input.parentId\r\n        );\r\n        if (isDescendant) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Cannot set a descendant as parent\",\r\n          });\r\n        }\r\n      }\r\n\r\n      return ctx.db.department.update({\r\n        where: { id },\r\n        data: updateData,\r\n        include: {\r\n          parent: true,\r\n          children: true,\r\n          users: true,\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Soft delete department\r\n  delete: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'DELETE',\r\n        path: '/departments/{id}',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Delete department',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Check if department exists\r\n      const department = await ctx.db.department.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          children: true,\r\n          users: true,\r\n        },\r\n      });\r\n\r\n      if (!department) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Department not found\",\r\n        });\r\n      }\r\n\r\n      // Check if department has active children\r\n      const activeChildren = department.children.filter(\r\n        (child) => !child.deletedAt\r\n      );\r\n      if (activeChildren.length > 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Cannot delete department with active child departments\",\r\n        });\r\n      }\r\n\r\n      // Check if department has active users\r\n      const activeUsers = department.users.filter((user) => !user.deletedAt);\r\n      if (activeUsers.length > 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Cannot delete department with active users\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.department.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: new Date(),\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Restore deleted department\r\n  restore: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/departments/{id}/restore',\r\n        protect: true,\r\n        tags: ['Departments'],\r\n        summary: 'Restore deleted department',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const department = await ctx.db.department.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!department) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Department not found\",\r\n        });\r\n      }\r\n\r\n      if (!department.deletedAt) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Department is not deleted\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.department.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: null,\r\n        },\r\n      });\r\n    }),\r\n});\r\n\r\n// Helper function to check if a department is a descendant of another\r\nasync function checkIsDescendant(\r\n  db: any,\r\n  ancestorId: string,\r\n  descendantId: string\r\n): Promise<boolean> {\r\n  const descendant = await db.department.findUnique({\r\n    where: { id: descendantId },\r\n    select: { parentId: true },\r\n  });\r\n\r\n  if (!descendant || !descendant.parentId) {\r\n    return false;\r\n  }\r\n\r\n  if (descendant.parentId === ancestorId) {\r\n    return true;\r\n  }\r\n\r\n  return checkIsDescendant(db, ancestorId, descendant.parentId);\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\notification.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[989,992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[989,992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":42,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":42,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .channel on an `any` value.","line":46,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":46,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .readAt on an `any` value.","line":50,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":50,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":56,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":56,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":437,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11465,11468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11465,11468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .channel on an `any` value.","line":440,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":440,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":444,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":444,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":446,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":446,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":446,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":446,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":449,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":449,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":449,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":449,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":454,"column":37,"nodeType":"Property","messageId":"anyAssignment","endLine":454,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":473,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":476,"endColumn":10}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport {\r\n  NotificationChannel,\r\n  NotificationStatus,\r\n} from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  adminProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const notificationRouter = createTRPCRouter({\r\n  // Get user's notifications\r\n  getMy: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/notifications/my',\r\n        protect: true,\r\n        tags: ['Notifications'],\r\n        summary: 'Get my notifications',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        status: z.nativeEnum(NotificationStatus).optional(),\r\n        channel: z.nativeEnum(NotificationChannel).optional(),\r\n        unreadOnly: z.boolean().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        userId: ctx.session.user.id,\r\n      };\r\n\r\n      if (input?.status) {\r\n        where.status = input.status;\r\n      }\r\n\r\n      if (input?.channel) {\r\n        where.channel = input.channel;\r\n      }\r\n\r\n      if (input?.unreadOnly) {\r\n        where.readAt = null;\r\n      }\r\n\r\n      const notifications = await ctx.db.notification.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (notifications.length > limit) {\r\n        const nextItem = notifications.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        notifications,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get unread count\r\n  getUnreadCount: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/notifications/unread-count',\r\n        protect: true,\r\n        tags: ['Notifications'],\r\n        summary: 'Get unread count',\r\n      }\r\n    })\r\n    .input(z.object({}))\r\n    .output(z.number())\r\n    .query(async ({ ctx }) => {\r\n    return ctx.db.notification.count({\r\n      where: {\r\n        userId: ctx.session.user.id,\r\n        readAt: null,\r\n      },\r\n    });\r\n  }),\r\n\r\n  // Get notification by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/notifications/{id}',\r\n        protect: true,\r\n        tags: ['Notifications'],\r\n        summary: 'Get notification by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const notification = await ctx.db.notification.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!notification) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Notification not found\",\r\n        });\r\n      }\r\n\r\n      // Only user can view their own notifications\r\n      if (notification.userId !== ctx.session.user.id && ctx.session.user.role !== \"ADMIN\") {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this notification\",\r\n        });\r\n      }\r\n\r\n      return notification;\r\n    }),\r\n\r\n  // Create notification (admin only, typically called by system)\r\n  create: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/notifications',\r\n        protect: true,\r\n        tags: ['Notifications'],\r\n        summary: 'Create notification',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        userId: z.string(),\r\n        title: z.string(),\r\n        message: z.string(),\r\n        channel: z.nativeEnum(NotificationChannel),\r\n        entityType: z.string().optional(),\r\n        entityId: z.string().optional(),\r\n        actionUrl: z.string().optional(),\r\n        priority: z.enum([\"LOW\", \"NORMAL\", \"HIGH\"]).optional(),\r\n        templateId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Verify user exists\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: input.userId },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      const notification = await ctx.db.notification.create({\r\n        data: {\r\n          userId: input.userId,\r\n          title: input.title,\r\n          message: input.message,\r\n          channel: input.channel,\r\n          entityType: input.entityType,\r\n          entityId: input.entityId,\r\n          actionUrl: input.actionUrl,\r\n          priority: input.priority ?? \"NORMAL\",\r\n          templateId: input.templateId,\r\n        },\r\n      });\r\n\r\n      // TODO: Queue notification for delivery based on channel\r\n\r\n      return notification;\r\n    }),\r\n\r\n  // Batch create notifications\r\n  createBatch: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/notifications/batch',\r\n        protect: true,\r\n        tags: ['Notifications'],\r\n        summary: 'Batch create notifications',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        userIds: z.array(z.string()),\r\n        title: z.string(),\r\n        message: z.string(),\r\n        channel: z.nativeEnum(NotificationChannel),\r\n        entityType: z.string().optional(),\r\n        entityId: z.string().optional(),\r\n        actionUrl: z.string().optional(),\r\n        priority: z.enum([\"LOW\", \"NORMAL\", \"HIGH\"]).optional(),\r\n      })\r\n    )\r\n    .output(z.object({ count: z.number() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { userIds, ...notificationData } = input;\r\n\r\n      // Verify all users exist\r\n      const users = await ctx.db.user.findMany({\r\n        where: {\r\n          id: { in: userIds },\r\n          deletedAt: null,\r\n        },\r\n      });\r\n\r\n      if (users.length !== userIds.length) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Some users not found\",\r\n        });\r\n      }\r\n\r\n      // Create notifications\r\n      const created = await ctx.db.notification.createMany({\r\n        data: userIds.map((userId) => ({\r\n          userId,\r\n          ...notificationData,\r\n        })),\r\n      });\r\n\r\n      // TODO: Queue notifications for delivery\r\n\r\n      return {\r\n        count: created.count,\r\n      };\r\n    }),\r\n\r\n  // Mark notification as read\r\n  markAsRead: protectedProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const notification = await ctx.db.notification.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!notification) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Notification not found\",\r\n        });\r\n      }\r\n\r\n      if (notification.userId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to modify this notification\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.notification.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          readAt: new Date(),\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Mark all notifications as read\r\n  markAllAsRead: protectedProcedure\r\n    .output(z.object({ count: z.number() }))\r\n    .mutation(async ({ ctx }) => {\r\n    const updated = await ctx.db.notification.updateMany({\r\n      where: {\r\n        userId: ctx.session.user.id,\r\n        readAt: null,\r\n      },\r\n      data: {\r\n        readAt: new Date(),\r\n      },\r\n    });\r\n\r\n    return {\r\n      count: updated.count,\r\n    };\r\n  }),\r\n\r\n  // Mark multiple notifications as read\r\n  markManyAsRead: protectedProcedure\r\n    .input(\r\n      z.object({\r\n        ids: z.array(z.string()),\r\n      })\r\n    )\r\n    .output(z.object({ count: z.number() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Verify all notifications belong to user\r\n      const notifications = await ctx.db.notification.findMany({\r\n        where: {\r\n          id: { in: input.ids },\r\n        },\r\n      });\r\n\r\n      const unauthorized = notifications.some(\r\n        (n) => n.userId !== ctx.session.user.id\r\n      );\r\n\r\n      if (unauthorized) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to modify some notifications\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.notification.updateMany({\r\n        where: {\r\n          id: { in: input.ids },\r\n          userId: ctx.session.user.id,\r\n        },\r\n        data: {\r\n          readAt: new Date(),\r\n        },\r\n      });\r\n\r\n      return {\r\n        count: updated.count,\r\n      };\r\n    }),\r\n\r\n  // Delete notification (soft delete)\r\n  delete: protectedProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const notification = await ctx.db.notification.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!notification) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Notification not found\",\r\n        });\r\n      }\r\n\r\n      if (notification.userId !== ctx.session.user.id && ctx.session.user.role !== \"ADMIN\") {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to delete this notification\",\r\n        });\r\n      }\r\n\r\n      // For notifications, we typically do a hard delete rather than soft delete\r\n      return ctx.db.notification.delete({\r\n        where: { id: input.id },\r\n      });\r\n    }),\r\n\r\n  // Delete all read notifications\r\n  deleteAllRead: protectedProcedure\r\n    .output(z.object({ count: z.number() }))\r\n    .mutation(async ({ ctx }) => {\r\n    const deleted = await ctx.db.notification.deleteMany({\r\n      where: {\r\n        userId: ctx.session.user.id,\r\n        readAt: { not: null },\r\n      },\r\n    });\r\n\r\n    return {\r\n      count: deleted.count,\r\n    };\r\n  }),\r\n\r\n  // Update notification status (for system tracking)\r\n  updateStatus: adminProcedure\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        status: z.nativeEnum(NotificationStatus),\r\n        sentAt: z.coerce.date().optional(),\r\n        deliveredAt: z.coerce.date().optional(),\r\n        failedAt: z.coerce.date().optional(),\r\n        errorMessage: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      const notification = await ctx.db.notification.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!notification) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Notification not found\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.notification.update({\r\n        where: { id },\r\n        data: updateData,\r\n      });\r\n    }),\r\n\r\n  // Get notification statistics (admin)\r\n  getStatistics: adminProcedure\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        channel: z.nativeEnum(NotificationChannel).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {};\r\n\r\n      if (input?.channel) {\r\n        where.channel = input.channel;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const [total, byStatus, byChannel, byPriority] = await Promise.all([\r\n        ctx.db.notification.count({ where }),\r\n        ctx.db.notification.groupBy({\r\n          by: [\"status\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.notification.groupBy({\r\n          by: [\"channel\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.notification.groupBy({\r\n          by: [\"priority\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n      ]);\r\n\r\n      const readCount = await ctx.db.notification.count({\r\n        where: {\r\n          ...where,\r\n          readAt: { not: null },\r\n        },\r\n      });\r\n\r\n      return {\r\n        total,\r\n        readCount,\r\n        unreadCount: total - readCount,\r\n        byStatus: byStatus.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        byChannel: byChannel.map((item) => ({\r\n          channel: item.channel,\r\n          count: item._count,\r\n        })),\r\n        byPriority: byPriority.map((item) => ({\r\n          priority: item.priority,\r\n          count: item._count,\r\n        })),\r\n      };\r\n    }),\r\n\r\n  // Resend failed notification\r\n  resend: adminProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const notification = await ctx.db.notification.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!notification) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Notification not found\",\r\n        });\r\n      }\r\n\r\n      if (notification.status !== NotificationStatus.FAILED) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only resend failed notifications\",\r\n        });\r\n      }\r\n\r\n      // Reset notification status\r\n      const updated = await ctx.db.notification.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: NotificationStatus.PENDING,\r\n          failedAt: null,\r\n          errorMessage: null,\r\n        },\r\n      });\r\n\r\n      // TODO: Queue notification for redelivery\r\n\r\n      return updated;\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\post.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\travelRequest.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1344,1347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1344,1347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .OR on an `any` value.","line":54,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":54,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":61,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":61,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .travelType on an `any` value.","line":65,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":65,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .requesterId on an `any` value.","line":69,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":69,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":73,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":73,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":75,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":75,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":75,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":75,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":78,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":78,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":78,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":78,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":85,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":85,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":850,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":850,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22969,22972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22969,22972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .requester on an `any` value.","line":855,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":855,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":861,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":861,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":863,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":863,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":863,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":863,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":866,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":866,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .AND on an `any` value.","line":866,"column":17,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":866,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":871,"column":38,"nodeType":"Property","messageId":"anyAssignment","endLine":871,"endColumn":43}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport {\r\n  TravelType,\r\n  TravelStatus,\r\n  ApprovalLevel,\r\n  ApprovalStatus,\r\n  AuditAction,\r\n} from \"../../../../generated/prisma\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  supervisorProcedure,\r\n  managerProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const travelRequestRouter = createTRPCRouter({\r\n  // Get all travel requests with filters\r\n  getAll: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/travel-requests',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Get all travel requests',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"list_my_travel_requests\",\r\n        description: \"List all travel requests for the current user that are eligible for claims\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        status: z.nativeEnum(TravelStatus).optional(),\r\n        travelType: z.nativeEnum(TravelType).optional(),\r\n        requesterId: z.string().optional(),\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n      };\r\n\r\n      // Non-managers can only see their own requests and their team's requests\r\n      if (![\"MANAGER\", \"DIRECTOR\", \"ADMIN\", \"FINANCE\"].includes(ctx.session.user.role)) {\r\n        where.OR = [\r\n          { requesterId: ctx.session.user.id },\r\n          { participants: { some: { userId: ctx.session.user.id } } },\r\n        ];\r\n      }\r\n\r\n      if (input?.status) {\r\n        where.status = input.status;\r\n      }\r\n\r\n      if (input?.travelType) {\r\n        where.travelType = input.travelType;\r\n      }\r\n\r\n      if (input?.requesterId) {\r\n        where.requesterId = input.requesterId;\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ startDate: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ endDate: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const requests = await ctx.db.travelRequest.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          requester: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              employeeId: true,\r\n              department: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          participants: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          approvals: {\r\n            include: {\r\n              approver: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  role: true,\r\n                },\r\n              },\r\n            },\r\n            orderBy: {\r\n              createdAt: \"asc\",\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: \"desc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (requests.length > limit) {\r\n        const nextItem = requests.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        requests,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get travel request by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/travel-requests/{id}',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Get travel request by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const request = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          requester: {\r\n            include: {\r\n              department: true,\r\n              supervisor: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          participants: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                  employeeId: true,\r\n                  department: {\r\n                    select: {\r\n                      id: true,\r\n                      name: true,\r\n                    },\r\n                  },\r\n                },\r\n              },\r\n            },\r\n          },\r\n          approvals: {\r\n            include: {\r\n              approver: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                  role: true,\r\n                },\r\n              },\r\n            },\r\n            orderBy: {\r\n              createdAt: \"asc\",\r\n            },\r\n          },\r\n          claims: {\r\n            include: {\r\n              submitter: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!request) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Check access rights\r\n      const isRequester = request.requesterId === ctx.session.user.id;\r\n      const isParticipant = request.participants.some(\r\n        (p) => p.userId === ctx.session.user.id\r\n      );\r\n      const canView = [\"MANAGER\", \"DIRECTOR\", \"ADMIN\", \"FINANCE\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isRequester && !isParticipant && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this travel request\",\r\n        });\r\n      }\r\n\r\n      return request;\r\n    }),\r\n\r\n  // Get pending approvals for current user\r\n  getPendingApprovals: supervisorProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/travel-requests/pending-approvals',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Get pending approvals for current user',\r\n      }\r\n    })\r\n    .input(z.object({}))\r\n    .output(z.any())\r\n    .query(async ({ ctx }) => {\r\n    return ctx.db.travelRequest.findMany({\r\n      where: {\r\n        deletedAt: null,\r\n        approvals: {\r\n          some: {\r\n            approverId: ctx.session.user.id,\r\n            status: ApprovalStatus.PENDING,\r\n          },\r\n        },\r\n      },\r\n      include: {\r\n        requester: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            email: true,\r\n            employeeId: true,\r\n            department: {\r\n              select: {\r\n                name: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        participants: {\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        approvals: {\r\n          where: {\r\n            approverId: ctx.session.user.id,\r\n            status: ApprovalStatus.PENDING,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n    });\r\n  }),\r\n\r\n  // Create travel request\r\n  create: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/travel-requests',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Create travel request',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        purpose: z.string().min(10),\r\n        destination: z.string().min(1),\r\n        travelType: z.nativeEnum(TravelType),\r\n        startDate: z.coerce.date(),\r\n        endDate: z.coerce.date(),\r\n        estimatedBudget: z.number().positive().optional(),\r\n        projectName: z.string().optional(),\r\n        customerName: z.string().optional(),\r\n        salesPerson: z.string().optional(),\r\n        participantIds: z.array(z.string()).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { participantIds, ...requestData } = input;\r\n\r\n      // Validate dates\r\n      if (input.startDate >= input.endDate) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"End date must be after start date\",\r\n        });\r\n      }\r\n\r\n      // Generate request number\r\n      const year = new Date().getFullYear();\r\n      const count = await ctx.db.travelRequest.count({\r\n        where: {\r\n          requestNumber: {\r\n            startsWith: `TR-${year}`,\r\n          },\r\n        },\r\n      });\r\n      const requestNumber = `TR-${year}-${String(count + 1).padStart(5, \"0\")}`;\r\n\r\n      // Create request\r\n      const request = await ctx.db.travelRequest.create({\r\n        data: {\r\n          requestNumber,\r\n          requesterId: ctx.session.user.id,\r\n          ...requestData,\r\n          participants: participantIds\r\n            ? {\r\n                create: participantIds.map((userId) => ({\r\n                  userId,\r\n                })),\r\n              }\r\n            : undefined,\r\n        },\r\n        include: {\r\n          requester: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n          participants: {\r\n            include: {\r\n              user: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CREATE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: request.id,\r\n          changes: {\r\n            after: request,\r\n          },\r\n        },\r\n      });\r\n\r\n      return request;\r\n    }),\r\n\r\n  // Update travel request (only in DRAFT or REVISION status)\r\n  update: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PUT',\r\n        path: '/travel-requests/{id}',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Update travel request',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        purpose: z.string().min(10).optional(),\r\n        destination: z.string().min(1).optional(),\r\n        travelType: z.nativeEnum(TravelType).optional(),\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        estimatedBudget: z.number().positive().optional(),\r\n        projectName: z.string().optional(),\r\n        customerName: z.string().optional(),\r\n        salesPerson: z.string().optional(),\r\n        participantIds: z.array(z.string()).optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, participantIds, ...updateData } = input;\r\n\r\n      const existing = await ctx.db.travelRequest.findUnique({\r\n        where: { id },\r\n        include: {\r\n          participants: true,\r\n        },\r\n      });\r\n\r\n      if (!existing) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Only requester can update\r\n      if (existing.requesterId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only the requester can update this request\",\r\n        });\r\n      }\r\n\r\n      // Can only update DRAFT or REVISION requests\r\n      if (!([TravelStatus.DRAFT, TravelStatus.REVISION] as TravelStatus[]).includes(existing.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only update requests in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      // Validate dates if both provided\r\n      if (updateData.startDate && updateData.endDate) {\r\n        if (updateData.startDate >= updateData.endDate) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"End date must be after start date\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Update participants if provided\r\n      if (participantIds) {\r\n        await ctx.db.travelParticipant.deleteMany({\r\n          where: { travelRequestId: id },\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.travelRequest.update({\r\n        where: { id },\r\n        data: {\r\n          ...updateData,\r\n          participants: participantIds\r\n            ? {\r\n                create: participantIds.map((userId) => ({\r\n                  userId,\r\n                })),\r\n              }\r\n            : undefined,\r\n        },\r\n        include: {\r\n          requester: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, phoneNumber: true, image: true } },\r\n          participants: {\r\n            include: {\r\n              user: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.UPDATE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: id,\r\n          changes: {\r\n            before: existing,\r\n            after: updated,\r\n          },\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Submit travel request for approval\r\n  submit: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/travel-requests/{id}/submit',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Submit travel request for approval',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const request = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          requester: {\r\n            include: {\r\n              supervisor: true,\r\n              department: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!request) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      if (request.requesterId !== ctx.session.user.id) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only the requester can submit this request\",\r\n        });\r\n      }\r\n\r\n      if (!([TravelStatus.DRAFT, TravelStatus.REVISION] as TravelStatus[]).includes(request.status)) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only submit requests in DRAFT or REVISION status\",\r\n        });\r\n      }\r\n\r\n      // Create approval workflow\r\n      const approvals = [];\r\n\r\n      // L1: Supervisor\r\n      if (request.requester.supervisorId) {\r\n        approvals.push({\r\n          level: ApprovalLevel.L1_SUPERVISOR,\r\n          approverId: request.requester.supervisorId,\r\n        });\r\n      }\r\n\r\n      // L2: Manager (department manager)\r\n      if (request.requester.department?.managerId) {\r\n        approvals.push({\r\n          level: ApprovalLevel.L2_MANAGER,\r\n          approverId: request.requester.department.managerId,\r\n        });\r\n      }\r\n\r\n      // L3: Director (department director)\r\n      if (request.requester.department?.directorId) {\r\n        approvals.push({\r\n          level: ApprovalLevel.L3_DIRECTOR,\r\n          approverId: request.requester.department.directorId,\r\n        });\r\n      }\r\n\r\n      // Update request and create approvals\r\n      const updated = await ctx.db.travelRequest.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: TravelStatus.SUBMITTED,\r\n          submittedAt: new Date(),\r\n          approvals: {\r\n            create: approvals,\r\n          },\r\n        },\r\n        include: {\r\n          approvals: {\r\n            include: {\r\n              approver: { select: { id: true, name: true, email: true, employeeId: true, role: true, departmentId: true, image: true } },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.SUBMIT,\r\n          entityType: \"TravelRequest\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      // TODO: Send notifications to approvers\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Lock travel request (Finance)\r\n  lock: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/travel-requests/{id}/lock',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Lock travel request',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      if (![\"FINANCE\", \"ADMIN\"].includes(ctx.session.user.role)) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only Finance or Admin can lock travel requests\",\r\n        });\r\n      }\r\n\r\n      const request = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!request) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      if (request.status !== TravelStatus.APPROVED) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only lock approved travel requests\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.travelRequest.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: TravelStatus.LOCKED,\r\n          lockedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.LOCK,\r\n          entityType: \"TravelRequest\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Close travel request (Finance)\r\n  close: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/travel-requests/{id}/close',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Close travel request',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      if (![\"FINANCE\", \"ADMIN\"].includes(ctx.session.user.role)) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Only Finance or Admin can close travel requests\",\r\n        });\r\n      }\r\n\r\n      const request = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          claims: {\r\n            where: {\r\n              status: {\r\n                notIn: [\"PAID\", \"REJECTED\"],\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!request) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      if (request.status !== TravelStatus.LOCKED) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only close locked travel requests\",\r\n        });\r\n      }\r\n\r\n      // Check if all claims are settled\r\n      if (request.claims.length > 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Cannot close request with pending claims\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.travelRequest.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          status: TravelStatus.CLOSED,\r\n          closedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.CLOSE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Delete travel request (soft delete)\r\n  delete: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'DELETE',\r\n        path: '/travel-requests/{id}',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Delete travel request',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const request = await ctx.db.travelRequest.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          claims: true,\r\n        },\r\n      });\r\n\r\n      if (!request) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"Travel request not found\",\r\n        });\r\n      }\r\n\r\n      // Only requester or admin can delete\r\n      const canDelete =\r\n        request.requesterId === ctx.session.user.id ||\r\n        ctx.session.user.role === \"ADMIN\";\r\n\r\n      if (!canDelete) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to delete this request\",\r\n        });\r\n      }\r\n\r\n      // Can only delete DRAFT requests\r\n      if (request.status !== TravelStatus.DRAFT) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Can only delete requests in DRAFT status\",\r\n        });\r\n      }\r\n\r\n      const updated = await ctx.db.travelRequest.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Create audit log\r\n      await ctx.db.auditLog.create({\r\n        data: {\r\n          userId: ctx.session.user.id,\r\n          action: AuditAction.DELETE,\r\n          entityType: \"TravelRequest\",\r\n          entityId: input.id,\r\n        },\r\n      });\r\n\r\n      return updated;\r\n    }),\r\n\r\n  // Get statistics\r\n  getStatistics: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/travel-requests/statistics',\r\n        protect: true,\r\n        tags: ['Travel Requests'],\r\n        summary: 'Get travel request statistics',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        startDate: z.coerce.date().optional(),\r\n        endDate: z.coerce.date().optional(),\r\n        departmentId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: null,\r\n      };\r\n\r\n      if (input?.departmentId) {\r\n        where.requester = {\r\n          departmentId: input.departmentId,\r\n        };\r\n      }\r\n\r\n      if (input?.startDate || input?.endDate) {\r\n        where.AND = [];\r\n        if (input.startDate) {\r\n          where.AND.push({ createdAt: { gte: input.startDate } });\r\n        }\r\n        if (input.endDate) {\r\n          where.AND.push({ createdAt: { lte: input.endDate } });\r\n        }\r\n      }\r\n\r\n      const [total, byStatus, byType] = await Promise.all([\r\n        ctx.db.travelRequest.count({ where }),\r\n        ctx.db.travelRequest.groupBy({\r\n          by: [\"status\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n        ctx.db.travelRequest.groupBy({\r\n          by: [\"travelType\"],\r\n          where,\r\n          _count: true,\r\n        }),\r\n      ]);\r\n\r\n      return {\r\n        total,\r\n        byStatus: byStatus.map((item) => ({\r\n          status: item.status,\r\n          count: item._count,\r\n        })),\r\n        byType: byType.map((item) => ({\r\n          type: item.travelType,\r\n          count: item._count,\r\n        })),\r\n      };\r\n    }),\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\routers\\user.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3719,3722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3719,3722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .role on an `any` value.","line":160,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":160,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .departmentId on an `any` value.","line":164,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":164,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .OR on an `any` value.","line":168,"column":15,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":168,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":179,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":179,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":721,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":721,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17934,17937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17934,17937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":725,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":728,"endColumn":5},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":725,"column":28,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":725,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .user on an `any` value.","line":725,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":725,"endColumn":35},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":730,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":730,"endColumn":46,"fix":{"range":[18141,18180],"text":"!supervisor?.supervisorId"}},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .supervisorId on an `any` value.","line":730,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":730,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .supervisorId on an `any` value.","line":734,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":734,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .supervisorId on an `any` value.","line":738,"column":57,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":738,"endColumn":69}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { z } from \"zod\";\r\nimport { TRPCError } from \"@trpc/server\";\r\nimport { Role } from \"../../../../generated/prisma\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nimport {\r\n  createTRPCRouter,\r\n  protectedProcedure,\r\n  adminProcedure,\r\n  managerProcedure,\r\n} from \"@/server/api/trpc\";\r\n\r\nexport const userRouter = createTRPCRouter({\r\n  // Get current user profile\r\n  getMe: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users/me',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get current user profile',\r\n      }\r\n    })\r\n    .input(z.void())\r\n    .output(z.any())\r\n    .query(async ({ ctx }) => {\r\n    const user = await ctx.db.user.findUnique({\r\n      where: { id: ctx.session.user.id },\r\n      include: {\r\n        department: true,\r\n        supervisor: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            email: true,\r\n            role: true,\r\n          },\r\n        },\r\n        directReports: {\r\n          where: { deletedAt: null },\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            email: true,\r\n            role: true,\r\n            employeeId: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      throw new TRPCError({\r\n        code: \"NOT_FOUND\",\r\n        message: \"User not found\",\r\n      });\r\n    }\r\n\r\n    return user;\r\n  }),\r\n\r\n  // Get user by phone number (dedicated MCP tool)\r\n  getByPhone: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users/by-phone',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get user by phone number',\r\n      },\r\n      mcp: {\r\n        enabled: true,\r\n        name: \"get_user_by_phone\",\r\n        description: \"Get user information by phone number\",\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        search: z.string().min(1),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const user = await ctx.db.user.findFirst({\r\n        where: {\r\n          deletedAt: null,\r\n          phoneNumber: { contains: input.search, mode: \"insensitive\" },\r\n        },\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n          emailVerified: true,\r\n          image: true,\r\n          employeeId: true,\r\n          role: true,\r\n          departmentId: true,\r\n          supervisorId: true,\r\n          phoneNumber: true,\r\n          deletedAt: true,\r\n          createdAt: true,\r\n          updatedAt: true,\r\n          department: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              code: true,\r\n            },\r\n          },\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              directReports: true,\r\n              travelRequests: true,\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      return { user };\r\n    }),\r\n\r\n  // Get all users with filters\r\n  getAll: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get all users',\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        role: z.nativeEnum(Role).optional(),\r\n        departmentId: z.string().optional(),\r\n        includeDeleted: z.boolean().optional(),\r\n        search: z.string().optional(),\r\n        limit: z.number().min(1).max(100).optional(),\r\n        cursor: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const where: any = {\r\n        deletedAt: input?.includeDeleted ? undefined : null,\r\n      };\r\n\r\n      if (input?.role) {\r\n        where.role = input.role;\r\n      }\r\n\r\n      if (input?.departmentId) {\r\n        where.departmentId = input.departmentId;\r\n      }\r\n\r\n      if (input?.search) {\r\n        where.OR = [\r\n          { name: { contains: input.search, mode: \"insensitive\" } },\r\n          { email: { contains: input.search, mode: \"insensitive\" } },\r\n          { employeeId: { contains: input.search, mode: \"insensitive\" } },\r\n          { phoneNumber: { contains: input.search, mode: \"insensitive\" } },\r\n        ];\r\n      }\r\n\r\n      const users = await ctx.db.user.findMany({\r\n        take: input?.limit ? input.limit + 1 : 51,\r\n        cursor: input?.cursor ? { id: input.cursor } : undefined,\r\n        where,\r\n        include: {\r\n          department: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              code: true,\r\n            },\r\n          },\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              directReports: true,\r\n              travelRequests: true,\r\n              claims: true,\r\n            },\r\n          },\r\n        },\r\n        orderBy: {\r\n          name: \"asc\",\r\n        },\r\n      });\r\n\r\n      let nextCursor: string | undefined = undefined;\r\n      const limit = input?.limit ?? 50;\r\n      if (users.length > limit) {\r\n        const nextItem = users.pop();\r\n        nextCursor = nextItem!.id;\r\n      }\r\n\r\n      return {\r\n        users,\r\n        nextCursor,\r\n      };\r\n    }),\r\n\r\n  // Get user by ID\r\n  getById: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users/{id}',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get user by ID',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          department: true,\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n            },\r\n          },\r\n          directReports: {\r\n            where: { deletedAt: null },\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n              role: true,\r\n              employeeId: true,\r\n            },\r\n          },\r\n          _count: {\r\n            select: {\r\n              travelRequests: true,\r\n              claims: true,\r\n              approvals: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      // Only allow viewing own profile or if user is manager/admin\r\n      const isOwn = user.id === ctx.session.user.id;\r\n      const canView = [\"MANAGER\", \"DIRECTOR\", \"ADMIN\"].includes(\r\n        ctx.session.user.role\r\n      );\r\n\r\n      if (!isOwn && !canView) {\r\n        throw new TRPCError({\r\n          code: \"FORBIDDEN\",\r\n          message: \"Not authorized to view this user\",\r\n        });\r\n      }\r\n\r\n      return user;\r\n    }),\r\n\r\n  // Get direct reports\r\n  getDirectReports: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users/direct-reports',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get direct reports',\r\n      }\r\n    })\r\n    .input(z.void())\r\n    .output(z.any())\r\n    .query(async ({ ctx }) => {\r\n    return ctx.db.user.findMany({\r\n      where: {\r\n        supervisorId: ctx.session.user.id,\r\n        deletedAt: null,\r\n      },\r\n      include: {\r\n        department: true,\r\n        _count: {\r\n          select: {\r\n            directReports: true,\r\n            travelRequests: true,\r\n            claims: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        name: \"asc\",\r\n      },\r\n    });\r\n  }),\r\n\r\n  // Get organizational hierarchy\r\n  getHierarchy: managerProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'GET',\r\n        path: '/users/hierarchy',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Get organizational hierarchy',\r\n      },\r\n    })\r\n    .input(\r\n      z.object({\r\n        userId: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .query(async ({ ctx, input }) => {\r\n      const rootUserId = input?.userId ?? ctx.session.user.id;\r\n\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: rootUserId },\r\n        include: {\r\n          department: true,\r\n          directReports: {\r\n            where: { deletedAt: null },\r\n            include: {\r\n              department: true,\r\n              directReports: {\r\n                where: { deletedAt: null },\r\n                include: {\r\n                  department: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      return user;\r\n    }),\r\n\r\n  // Create user\r\n  create: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/users',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Create user',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        name: z.string().min(1),\r\n        email: z.string().email(),\r\n        password: z.string().min(8),\r\n        employeeId: z.string().optional(),\r\n        role: z.nativeEnum(Role).optional(),\r\n        departmentId: z.string().optional(),\r\n        supervisorId: z.string().optional(),\r\n        phoneNumber: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      // Check if email already exists\r\n      const existing = await ctx.db.user.findUnique({\r\n        where: { email: input.email },\r\n      });\r\n\r\n      if (existing) {\r\n        throw new TRPCError({\r\n          code: \"CONFLICT\",\r\n          message: \"Email already exists\",\r\n        });\r\n      }\r\n\r\n      // Check if employeeId already exists\r\n      if (input.employeeId) {\r\n        const existingEmployee = await ctx.db.user.findUnique({\r\n          where: { employeeId: input.employeeId },\r\n        });\r\n\r\n        if (existingEmployee) {\r\n          throw new TRPCError({\r\n            code: \"CONFLICT\",\r\n            message: \"Employee ID already exists\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Hash password\r\n      const hashedPassword = await bcrypt.hash(input.password, 10);\r\n\r\n      return ctx.db.user.create({\r\n        data: {\r\n          name: input.name,\r\n          email: input.email,\r\n          password: hashedPassword,\r\n          employeeId: input.employeeId,\r\n          role: input.role ?? Role.EMPLOYEE,\r\n          departmentId: input.departmentId,\r\n          supervisorId: input.supervisorId,\r\n          phoneNumber: input.phoneNumber,\r\n        },\r\n        include: {\r\n          department: true,\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Update user\r\n  update: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PUT',\r\n        path: '/users/{id}',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Update user',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        id: z.string(),\r\n        name: z.string().min(1).optional(),\r\n        email: z.string().email().optional(),\r\n        employeeId: z.string().optional(),\r\n        role: z.nativeEnum(Role).optional(),\r\n        departmentId: z.string().optional().nullable(),\r\n        supervisorId: z.string().optional().nullable(),\r\n        phoneNumber: z.string().optional().nullable(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const { id, ...updateData } = input;\r\n\r\n      // Check if user exists\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      // Check email uniqueness\r\n      if (input.email && input.email !== user.email) {\r\n        const existing = await ctx.db.user.findUnique({\r\n          where: { email: input.email },\r\n        });\r\n        if (existing) {\r\n          throw new TRPCError({\r\n            code: \"CONFLICT\",\r\n            message: \"Email already exists\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Check employeeId uniqueness\r\n      if (input.employeeId && input.employeeId !== user.employeeId) {\r\n        const existing = await ctx.db.user.findUnique({\r\n          where: { employeeId: input.employeeId },\r\n        });\r\n        if (existing) {\r\n          throw new TRPCError({\r\n            code: \"CONFLICT\",\r\n            message: \"Employee ID already exists\",\r\n          });\r\n        }\r\n      }\r\n\r\n      // Prevent circular supervisor references\r\n      if (input.supervisorId) {\r\n        if (input.supervisorId === id) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"User cannot be their own supervisor\",\r\n          });\r\n        }\r\n\r\n        const isCircular = await checkCircularSupervisor(\r\n          ctx.db,\r\n          id,\r\n          input.supervisorId\r\n        );\r\n        if (isCircular) {\r\n          throw new TRPCError({\r\n            code: \"BAD_REQUEST\",\r\n            message: \"Circular supervisor reference detected\",\r\n          });\r\n        }\r\n      }\r\n\r\n      return ctx.db.user.update({\r\n        where: { id },\r\n        data: updateData,\r\n        include: {\r\n          department: true,\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Update own profile\r\n  updateMe: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'PATCH',\r\n        path: '/users/me',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Update own profile',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        name: z.string().min(1).optional(),\r\n        phoneNumber: z.string().optional(),\r\n      })\r\n    )\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      return ctx.db.user.update({\r\n        where: { id: ctx.session.user.id },\r\n        data: input,\r\n        include: {\r\n          department: true,\r\n          supervisor: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              email: true,\r\n            },\r\n          },\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Change password\r\n  changePassword: protectedProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'POST',\r\n        path: '/users/change-password',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Change password',\r\n      }\r\n    })\r\n    .input(\r\n      z.object({\r\n        currentPassword: z.string(),\r\n        newPassword: z.string().min(8),\r\n      })\r\n    )\r\n    .output(z.object({ success: z.boolean() }))\r\n    .mutation(async ({ ctx, input }) => {\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: ctx.session.user.id },\r\n        select: { password: true },\r\n      });\r\n\r\n      if (!user?.password) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"User has no password set\",\r\n        });\r\n      }\r\n\r\n      // Verify current password\r\n      const isValid = await bcrypt.compare(input.currentPassword, user.password);\r\n      if (!isValid) {\r\n        throw new TRPCError({\r\n          code: \"UNAUTHORIZED\",\r\n          message: \"Current password is incorrect\",\r\n        });\r\n      }\r\n\r\n      // Hash new password\r\n      const hashedPassword = await bcrypt.hash(input.newPassword, 10);\r\n\r\n      await ctx.db.user.update({\r\n        where: { id: ctx.session.user.id },\r\n        data: { password: hashedPassword },\r\n      });\r\n\r\n      return { success: true };\r\n    }),\r\n\r\n  // Soft delete user\r\n  delete: adminProcedure\r\n    .meta({\r\n      openapi: {\r\n        method: 'DELETE',\r\n        path: '/users/{id}',\r\n        protect: true,\r\n        tags: ['Users'],\r\n        summary: 'Delete user',\r\n      }\r\n    })\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: input.id },\r\n        include: {\r\n          directReports: {\r\n            where: { deletedAt: null },\r\n          },\r\n        },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      // Check if user has active direct reports\r\n      if (user.directReports.length > 0) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"Cannot delete user with active direct reports\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.user.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: new Date(),\r\n        },\r\n      });\r\n    }),\r\n\r\n  // Restore deleted user\r\n  restore: adminProcedure\r\n    .input(z.object({ id: z.string() }))\r\n    .output(z.any())\r\n    .mutation(async ({ ctx, input }) => {\r\n      const user = await ctx.db.user.findUnique({\r\n        where: { id: input.id },\r\n      });\r\n\r\n      if (!user) {\r\n        throw new TRPCError({\r\n          code: \"NOT_FOUND\",\r\n          message: \"User not found\",\r\n        });\r\n      }\r\n\r\n      if (!user.deletedAt) {\r\n        throw new TRPCError({\r\n          code: \"BAD_REQUEST\",\r\n          message: \"User is not deleted\",\r\n        });\r\n      }\r\n\r\n      return ctx.db.user.update({\r\n        where: { id: input.id },\r\n        data: {\r\n          deletedAt: null,\r\n        },\r\n      });\r\n    }),\r\n});\r\n\r\n// Helper function to check circular supervisor references\r\nasync function checkCircularSupervisor(\r\n  db: any,\r\n  userId: string,\r\n  supervisorId: string\r\n): Promise<boolean> {\r\n  const supervisor = await db.user.findUnique({\r\n    where: { id: supervisorId },\r\n    select: { supervisorId: true },\r\n  });\r\n\r\n  if (!supervisor || !supervisor.supervisorId) {\r\n    return false;\r\n  }\r\n\r\n  if (supervisor.supervisorId === userId) {\r\n    return true;\r\n  }\r\n\r\n  return checkCircularSupervisor(db, userId, supervisor.supervisorId);\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\api\\trpc.ts","messages":[{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":198,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":198,"endColumn":42,"fix":{"range":[5668,5701],"text":"!ctx.session?.user"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\r\n * 1. You want to modify request context (see Part 1).\r\n * 2. You want to create a new middleware or type of procedure (see Part 3).\r\n *\r\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\r\n * need to use are documented accordingly near the end.\r\n */\r\n\r\nimport { initTRPC, TRPCError } from \"@trpc/server\";\r\nimport superjson from \"superjson\";\r\nimport { ZodError } from \"zod\";\r\nimport { type McpMeta } from \"trpc-to-mcp\";\r\nimport { type Role } from \"../../../generated/prisma\";\r\n\r\n// OpenApiMeta stub â€” trpc-to-openapi removed (zod v4 incompatible).\r\n// Keeps existing .meta({ openapi: ... }) calls compiling without the package.\r\ninterface OpenApiMeta {\r\n  openapi?: {\r\n    method?: string;\r\n    path?: string;\r\n    summary?: string;\r\n    description?: string;\r\n    tags?: string[];\r\n    protect?: boolean;\r\n    [key: string]: unknown;\r\n  };\r\n}\r\n\r\nimport { auth } from \"@/server/auth\";\r\nimport { db } from \"@/server/db\";\r\n\r\n/**\r\n * 1. CONTEXT\r\n *\r\n * This section defines the \"contexts\" that are available in the backend API.\r\n *\r\n * These allow you to access things when processing a request, like the database, the session, etc.\r\n *\r\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\r\n * wrap this and provides the required context.\r\n *\r\n * @see https://trpc.io/docs/server/context\r\n */\r\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\r\n  const session = await auth();\r\n\r\n  return {\r\n    db,\r\n    session,\r\n    ...opts,\r\n  };\r\n};\r\n\r\n/**\r\n * 2. INITIALIZATION\r\n *\r\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\r\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\r\n * errors on the backend.\r\n */\r\nconst t = initTRPC\r\n  .context<typeof createTRPCContext>()\r\n  .meta<McpMeta & OpenApiMeta>()\r\n  .create({\r\n    transformer: superjson,\r\n    errorFormatter({ shape, error }) {\r\n      return {\r\n        ...shape,\r\n        data: {\r\n          ...shape.data,\r\n          zodError:\r\n            error.cause instanceof ZodError ? error.cause.flatten() : null,\r\n        },\r\n      };\r\n    },\r\n  });\r\n\r\n/**\r\n * Create a server-side caller.\r\n *\r\n * @see https://trpc.io/docs/server/server-side-calls\r\n */\r\nexport const createCallerFactory = t.createCallerFactory;\r\n\r\n/**\r\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\r\n *\r\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\r\n * \"/src/server/api/routers\" directory.\r\n */\r\n\r\n/**\r\n * This is how you create new routers and sub-routers in your tRPC API.\r\n *\r\n * @see https://trpc.io/docs/router\r\n */\r\nexport const createTRPCRouter = t.router;\r\n\r\n/**\r\n * Middleware for timing procedure execution and adding an artificial delay in development.\r\n *\r\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\r\n * network latency that would occur in production but not in local development.\r\n */\r\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\r\n  const start = Date.now();\r\n\r\n  if (t._config.isDev) {\r\n    // artificial delay in dev\r\n    const waitMs = Math.floor(Math.random() * 400) + 100;\r\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\r\n  }\r\n\r\n  const result = await next();\r\n\r\n  const end = Date.now();\r\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * Public (unauthenticated) procedure\r\n *\r\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\r\n * guarantee that a user querying is authorized, but you can still access user session data if they\r\n * are logged in.\r\n */\r\nexport const publicProcedure = t.procedure.use(timingMiddleware);\r\n\r\n/**\r\n * Middleware: Enforce user authentication\r\n *\r\n * Throws UNAUTHORIZED error if user is not authenticated\r\n */\r\nconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {\r\n  if (!ctx.session?.user) {\r\n    throw new TRPCError({\r\n      code: \"UNAUTHORIZED\",\r\n      message: \"Authentication required\"\r\n    });\r\n  }\r\n  return next({\r\n    ctx: {\r\n      ...ctx,\r\n      // infers the `session` as non-nullable\r\n      session: { ...ctx.session, user: ctx.session.user },\r\n    },\r\n  });\r\n});\r\n\r\n/**\r\n * Middleware: Enforce role requirements\r\n *\r\n * @param allowedRoles - Array of roles that are allowed to access this procedure\r\n */\r\nconst enforceRole = (allowedRoles: Role[]) => {\r\n  return t.middleware(({ ctx, next }) => {\r\n    if (!ctx.session?.user?.role) {\r\n      throw new TRPCError({\r\n        code: \"UNAUTHORIZED\",\r\n        message: \"Authentication required\"\r\n      });\r\n    }\r\n    if (!allowedRoles.includes(ctx.session.user.role)) {\r\n      throw new TRPCError({\r\n        code: \"FORBIDDEN\",\r\n        message: \"Insufficient permissions for this operation\"\r\n      });\r\n    }\r\n    return next({\r\n      ctx: {\r\n        ...ctx,\r\n        // Preserve the non-nullable session type from protectedProcedure\r\n        session: ctx.session,\r\n      },\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Protected (authenticated) procedure\r\n *\r\n * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\r\n * the session is valid and guarantees `ctx.session.user` is not null.\r\n *\r\n * @see https://trpc.io/docs/procedures\r\n */\r\n// export const protectedProcedure = t.procedure\r\n//   .use(timingMiddleware)\r\n//   .use(enforceUserIsAuthed);\r\n\r\n  export const protectedProcedure = t.procedure\r\n  .use(timingMiddleware)\r\n  .use(enforceUserIsAuthed)\r\n  .use(({ ctx, next }) => {\r\n    if (!ctx.session || !ctx.session.user) {\r\n      throw new TRPCError({ code: \"UNAUTHORIZED\" });\r\n    }\r\n    return next({\r\n      ctx: {\r\n        ...ctx,\r\n        // infers the `session` as non-nullable\r\n        session: { ...ctx.session, user: ctx.session.user },\r\n      },\r\n    });\r\n  });\r\n\r\n\r\n/**\r\n * Supervisor procedure - requires SUPERVISOR, MANAGER, DIRECTOR, or ADMIN role\r\n */\r\nexport const supervisorProcedure = protectedProcedure\r\n  .use(enforceRole([\"SUPERVISOR\", \"MANAGER\", \"DIRECTOR\", \"ADMIN\"]));\r\n\r\n/**\r\n * Manager procedure - requires MANAGER, DIRECTOR, or ADMIN role\r\n */\r\nexport const managerProcedure = protectedProcedure\r\n  .use(enforceRole([\"MANAGER\", \"DIRECTOR\", \"ADMIN\"]));\r\n\r\n/**\r\n * Director procedure - requires DIRECTOR or ADMIN role\r\n */\r\nexport const directorProcedure = protectedProcedure\r\n  .use(enforceRole([\"DIRECTOR\", \"ADMIN\"]));\r\n\r\n/**\r\n * Finance procedure - requires FINANCE or ADMIN role\r\n */\r\nexport const financeProcedure = protectedProcedure\r\n  .use(enforceRole([\"FINANCE\", \"ADMIN\"]));\r\n\r\n/**\r\n * Admin procedure - requires ADMIN role only\r\n */\r\nexport const adminProcedure = protectedProcedure\r\n  .use(enforceRole([\"ADMIN\"]));\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\auth\\config.ts","messages":[{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'credentials.password' will use Object's default stringification format ('[object Object]') when stringified.","line":102,"column":18,"nodeType":"MemberExpression","messageId":"baseToString","endLine":102,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":141,"column":3,"nodeType":"Property","messageId":"anyAssignment","endLine":141,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4402,4405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4402,4405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":177,"column":15,"nodeType":"Property","messageId":"anyAssignment","endLine":177,"endColumn":105},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5520,5523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5520,5523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .extension_employeeId on an `any` value.","line":177,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":177,"endColumn":65},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5562,5565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5562,5565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .employeeId on an `any` value.","line":177,"column":87,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":177,"endColumn":97},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'profile' is defined but never used. Allowed unused args must match /^_/u.","line":202,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":202,"endColumn":46}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaAdapter } from \"@auth/prisma-adapter\";\r\nimport { type DefaultSession, type NextAuthConfig } from \"next-auth\";\r\nimport AzureADProvider from \"next-auth/providers/azure-ad\";\r\nimport GoogleProvider from \"next-auth/providers/google\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport { db } from \"@/server/db\";\r\nimport { env } from \"@/env\";\r\n\r\n// Import Role type\r\ntype Role = \"EMPLOYEE\" | \"SUPERVISOR\" | \"MANAGER\" | \"DIRECTOR\" | \"FINANCE\" | \"ADMIN\";\r\n\r\n/**\r\n * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\r\n * object and keep type safety.\r\n *\r\n * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\r\n */\r\ndeclare module \"next-auth\" {\r\n  interface Session extends DefaultSession {\r\n    user: {\r\n      id: string;\r\n      role: Role;\r\n      email: string;\r\n      employeeId: string | null;\r\n      departmentId: string | null;\r\n    } & DefaultSession[\"user\"];\r\n  }\r\n\r\n  interface User {\r\n    role: Role;\r\n    employeeId: string | null;\r\n    departmentId: string | null;\r\n  }\r\n}\r\n\r\n/**\r\n * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\r\n *\r\n * @see https://next-auth.js.org/configuration/options\r\n */\r\nexport const authConfig = {\r\n  secret: process.env.AUTH_SECRET,\r\n  trustHost: true,\r\n  providers: [\r\n    // Credentials provider (always available)\r\n    CredentialsProvider({\r\n      name: \"credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"text\" },\r\n        password: { label: \"Password\", type: \"password\" },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email) {\r\n          throw new Error(\"Invalid credentials: email not provided.\");\r\n        }\r\n\r\n        const user = await db.user.findUnique({\r\n          where: { email: credentials.email as string },\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            email: true,\r\n            password: true,\r\n            role: true,\r\n            employeeId: true,\r\n            departmentId: true,\r\n            image: true,\r\n          },\r\n        });\r\n\r\n        if (!user) {\r\n          throw new Error(\"No user found with the given email.\");\r\n        }\r\n\r\n        // In non-production environments, allow passwordless login with a specific bypass key.\r\n        if (\r\n          process.env.NODE_ENV !== \"production\" &&\r\n          credentials.password === process.env.NEXT_PUBLIC_BYPASS_SECRET\r\n        ) {\r\n          console.log(`Bypassing password validation for ${user.email}.`);\r\n          return {\r\n            id: user.id,\r\n            name: user.name,\r\n            email: user.email,\r\n            role: user.role,\r\n            employeeId: user.employeeId,\r\n            departmentId: user.departmentId,\r\n          };\r\n        }\r\n\r\n        if (!credentials.password) {\r\n          throw new Error(\"Invalid credentials: password not provided.\");\r\n        }\r\n\r\n        if (!user.password) {\r\n          throw new Error(\"The user does not have a password set up.\");\r\n        }\r\n\r\n        // Validate password\r\n        const isPasswordValid = await bcrypt.compare(\r\n          String(credentials.password),\r\n          String(user.password),\r\n        );\r\n\r\n        if (!isPasswordValid) {\r\n          throw new Error(\"Invalid password.\");\r\n        }\r\n\r\n        return {\r\n          id: user.id,\r\n          name: user.name,\r\n          email: user.email,\r\n          role: user.role,\r\n          employeeId: user.employeeId,\r\n          departmentId: user.departmentId,\r\n        };\r\n      },\r\n    }),\r\n    // Azure AD provider (conditional)\r\n    ...(env.AZURE_AD_CLIENT_ID && env.AZURE_AD_CLIENT_SECRET && env.AZURE_AD_TENANT_ID ? [\r\n      AzureADProvider({\r\n        clientId: env.AZURE_AD_CLIENT_ID,\r\n        clientSecret: env.AZURE_AD_CLIENT_SECRET,\r\n        issuer: `https://login.microsoftonline.com/${env.AZURE_AD_TENANT_ID}/v2.0`,\r\n        authorization: {\r\n          params: {\r\n            scope: \"openid profile email offline_access User.Read\",\r\n          },\r\n        },\r\n      }),\r\n    ] : []),\r\n    // Google provider (conditional)\r\n    ...(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET ? [\r\n      GoogleProvider({\r\n        clientId: process.env.GOOGLE_CLIENT_ID,\r\n        clientSecret: process.env.GOOGLE_CLIENT_SECRET,\r\n      }),\r\n    ] : []),\r\n  ],\r\n  adapter: PrismaAdapter(db) as any,\r\n  session: {\r\n    strategy: \"jwt\",\r\n  },\r\n  pages: {\r\n    signIn: \"/login\",\r\n    error: \"/auth/error\",\r\n  },\r\n  callbacks: {\r\n    async signIn({ user, account, profile }) {\r\n      try {\r\n        // Skip database operations for credentials provider (already handled in authorize)\r\n        if (account?.provider === \"credentials\") {\r\n          return true;\r\n        }\r\n\r\n        if (!user.email) {\r\n          console.error(\"No email provided from OAuth provider\");\r\n          return false;\r\n        }\r\n\r\n        // Look up existing user by email (for OAuth providers only)\r\n        const existingUser = await db.user.findUnique({\r\n          where: { email: user.email },\r\n          include: { department: true },\r\n        });\r\n\r\n        if (!existingUser) {\r\n          // First-time login: create user with default EMPLOYEE role\r\n          const newUser = await db.user.create({\r\n            data: {\r\n              email: user.email,\r\n              name: user.name,\r\n              image: user.image,\r\n              emailVerified: new Date(),\r\n              role: \"EMPLOYEE\",\r\n              employeeId: (profile as any)?.extension_employeeId ?? (profile as any)?.employeeId ?? null,\r\n            },\r\n          });\r\n\r\n          console.log(`Created new user: ${newUser.email} with role EMPLOYEE`);\r\n        } else {\r\n          // Update existing user profile\r\n          await db.user.update({\r\n            where: { id: existingUser.id },\r\n            data: {\r\n              name: user.name ?? existingUser.name,\r\n              image: user.image ?? existingUser.image,\r\n              emailVerified: existingUser.emailVerified ?? new Date(),\r\n              updatedAt: new Date(),\r\n            },\r\n          });\r\n        }\r\n\r\n        return true;\r\n      } catch (error) {\r\n        console.error(\"Error in signIn callback:\", error);\r\n        return false;\r\n      }\r\n    },\r\n\r\n    async jwt({ token, user, account, profile, trigger }) {\r\n      // Initial sign in\r\n      if (user) {\r\n        // For credentials provider, user object already has all needed data\r\n        if (account?.provider === \"credentials\") {\r\n          token.id = user.id;\r\n          token.role = user.role;\r\n          token.employeeId = user.employeeId;\r\n          token.departmentId = user.departmentId;\r\n          token.email = user.email;\r\n          token.name = user.name;\r\n          token.picture = user.image;\r\n        } else {\r\n          // For OAuth providers, fetch from database\r\n          const dbUser = await db.user.findUnique({\r\n            where: { id: user.id },\r\n            select: {\r\n              id: true,\r\n              role: true,\r\n              employeeId: true,\r\n              departmentId: true,\r\n              email: true,\r\n              name: true,\r\n              image: true,\r\n            },\r\n          });\r\n\r\n          if (dbUser) {\r\n            token.id = dbUser.id;\r\n            token.role = dbUser.role;\r\n            token.employeeId = dbUser.employeeId;\r\n            token.departmentId = dbUser.departmentId;\r\n            token.email = dbUser.email;\r\n            token.name = dbUser.name;\r\n            token.picture = dbUser.image;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Refresh user data on update trigger\r\n      if (trigger === \"update\" && token.id) {\r\n        const dbUser = await db.user.findUnique({\r\n          where: { id: token.id as string },\r\n          select: {\r\n            id: true,\r\n            role: true,\r\n            employeeId: true,\r\n            departmentId: true,\r\n            email: true,\r\n            name: true,\r\n            image: true,\r\n          },\r\n        });\r\n\r\n        if (dbUser) {\r\n          token.role = dbUser.role;\r\n          token.employeeId = dbUser.employeeId;\r\n          token.departmentId = dbUser.departmentId;\r\n          token.email = dbUser.email;\r\n          token.name = dbUser.name;\r\n          token.picture = dbUser.image;\r\n        }\r\n      }\r\n\r\n      return token;\r\n    },\r\n\r\n    async session({ session, token }) {\r\n      if (token && session.user) {\r\n        session.user.id = token.id as string;\r\n        session.user.role = token.role as Role;\r\n        session.user.employeeId = token.employeeId as string | null;\r\n        session.user.departmentId = token.departmentId as string | null;\r\n        session.user.email = token.email as string;\r\n        session.user.name = token.name as string;\r\n        session.user.image = token.picture as string;\r\n      }\r\n\r\n      return session;\r\n    },\r\n  },\r\n  events: {\r\n    async signIn({ user, account, profile: _profile, isNewUser }) {\r\n      // Log authentication event for audit\r\n      if (user.id) {\r\n        try {\r\n          await db.auditLog.create({\r\n            data: {\r\n              userId: user.id,\r\n              action: \"CREATE\",\r\n              entityType: \"Authentication\",\r\n              entityId: user.id,\r\n              metadata: {\r\n                provider: account?.provider,\r\n                isNewUser,\r\n                timestamp: new Date().toISOString(),\r\n              },\r\n            },\r\n          });\r\n        } catch (error) {\r\n          console.error(\"Failed to create audit log:\", error);\r\n        }\r\n      }\r\n    },\r\n  },\r\n} satisfies NextAuthConfig;","usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\auth\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\server\\openapi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\trpc\\query-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\trpc\\react.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\AISTECH\\travel-claim\\src\\trpc\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]